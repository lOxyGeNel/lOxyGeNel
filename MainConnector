#SingleInstance force
SetBatchLines -1
SendMode Input
CoordMode, window
#MaxThreadsPerHotkey 3

pToken:=Gdip_Startup()
global HB_Button:=[]
global HB_Switch:=[]

global OnOff=0

While (dev := VA_GetDevice("playback:" A_Index))
{
    devlist .= A_Index ": " VA_GetDeviceName(dev) "|"
}


I_Icon = Connect.ico
IfExist, %I_Icon%
  Menu, Tray, Icon, %I_Icon%
FileSetAttrib, -R, Main.ahk
FileDelete, Main.ahk

hBitmap := Gdip_CreateHBITMAPFromBitmap(Back_Ground_HUD())


xWin:= A_ScreenWidth/2.5
yWin:= A_ScreenHeight/2.5
xWindows:=(xWin-10)
yWindows:=(yWin-6)
Width :=A_ScreenWidth
Height := A_ScreenHeight


HotkeyMonture=0
HotkeyAppats=0
HotkeyCanne=0
HotkeySTOP=0




IniRead, xCoordPeche , Setting.ini,CoordZone,xCoordPeche
IniRead, yCoordPeche , Setting.ini,CoordZone,yCoordPeche
IniRead, wCoordPeche , Setting.ini,CoordZone,wCoordPeche
IniRead, hCoordPeche , Setting.ini,CoordZone,hCoordPeche
IniRead, xCoordVente , Setting.ini,CoordZone,xCoordVente
IniRead, yCoordVente , Setting.ini,CoordZone,yCoordVente
IniRead, wCoordVente , Setting.ini,CoordZone,wCoordVente
IniRead, hCoordVente , Setting.ini,CoordZone,hCoordVente
IniRead, HotkeyMonture ,Setting.ini, Raccourcis , Monture
IniRead, HotkeyAppats ,Setting.ini, Raccourcis , Appats
IniRead, HotkeyCanne ,Setting.ini, Raccourcis , Canne
IniRead, HotkeySTOP ,Setting.ini, Raccourcis , Stop
IniRead, audioSource1 ,Setting.ini, Audio , AudioSource
IniRead, SelectAudio ,Setting.ini, Audio , SelectAudio
HotkeyAssign()




;#####################################################################################
;                               MAIN MENU
;#####################################################################################
gui,1:new
Gui,1: -Caption +LastFound +hwndParent +AlwaysOntop
Gui, 1:Add, Text, 0xE w500 h300 hwndhsplash
SendMessage, 0x172, 0, hBitmap,, ahk_id %hsplash% ; STM_SETIMAGE = 0x172
Gui, Font, s9 Bold, Comfortaa
Gui,1:Color,00FF00
WinSet, Transcolor, 00FF00



HB_Button.Push(New Button_Type_69(x:=33,y:=55,w:=86,h:=22,Window:="1",Label:="MenuPeche",Text:="Peche",Font:="",Font_Size:="",Font_Color_Top:="",Font_Color_Bottom:="",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Button_Type_69(x:=33,y+=+29,w:=86,h:=22,Window:="1",Label:="MenuParametre",Text:="Parametres",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Button_Type_69(x:=33,y+=+29,w:=86,h:=22,Window:="1",Label:="MenuVersion",Text:="Version",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))

HB_Button.Push(New Button_Type_Minimize(x:=310,y:=16,w:=15,h:=15,Window:="1",Label:="WinMinimize",Text:="Button",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Button_Type_Exit(x:=330,y:=16,w:=15,h:=15,Window:="1",Label:="Exit",Text:="Button",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))

Gui,1:Add,Text,x4 y4 w343 h27 +BackgroundTrans gMoveWin,
Gui,1:show,x%xWindows% y%yWindows% w357 h245,Connector
Settimer,HB_Hover_Function,25
gosub MenuVersion
return


;#####################################################################################
;                               MENU PECHE
;#####################################################################################



MenuPeche:
If MenuPecheShow=1
    return
ResetMenu()
If MenuPecheShow=0
    DeleteGui()
MenuPecheShow=1

Gui, MenuPeche:new
Gui, MenuPeche:+hwndMenuPeche +ToolWindow -Caption +Parent1 +lastfound
HB_Button.Push(New Button_Type_69(x:=37,y:=120,w:=125,h:=22,Window:="MenuPeche",Label:="MenuPecheAvance",Text:="Options Avancees",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))


HB_Button.Push(New Button_Type_69(x:=10,y+=+35,w:=180,h:=22,Window:="MenuPeche",Label:="BotPeche",Text:="Start Bot",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Button_Type_69(x:=10,y:=155,w:=180,h:=22,Window:="MenuPeche",Label:="BotPecheOff",Text:="Stop Bot",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))


HB_Switch[1] :=(New Flat_Round_Switch_Type_1(x:=2,y:=6,w:=2 h:=1,Text:="Vendre Item Gris",Font:="Comfortaa",FontSize:= "12 Bold" , FontColor:="FFFFFF" ,Window:="MenuPeche",Background_Color:="0xFF4C4F54",State:=0))
HB_Switch[2] :=(New Flat_Round_Switch_Type_1(x:=2,y+=+20,w:=2 h:=1,Text:="Appats Automatique",Font:="Comfortaa",FontSize:= "12 Bold" , FontColor:="FFFFFF" ,Window:="MenuPeche",Background_Color:="0xFF4C4F54",State:=0))
Gui, MenuPeche:Add, Text, x15  y148    w170   h1    0x4
Gui,MenuPeche:Color,00FF00
WinSet, Transcolor, 00FF00
Gui,MenuPeche:show,x144 y47 h180 w200
OnOffVerif()
return





;#####################################################################################
;                               MENU PECHE AVANCEE
;#####################################################################################


MenuPecheAvance:
If MenuPecheAvanceShow=1
    return
ResetMenu()
If MenuPecheAvanceShow=0
    DeleteGui()
MenuPecheAvanceShow=1

Gui, MenuPecheAvance:new
Gui,+hwndMenuPecheAvance +ToolWindow -Caption +Parent1 +lastfound
HB_Button.Push(New Message(x:=45,y:=0,w:=105,h:=15,Window:="MenuPecheAvance",Label:="",Text:="Zone De Peche",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Message(x:=45,y:=65,w:=105,h:=15,Window:="MenuPecheAvance",Label:="",Text:="Zone De Vente",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Button_Type_69(x:=10,y:=20,w:=80,h:=35,Window:="MenuPecheAvance",Label:="ZonePeche",Text:="Delimiter une zone",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Button_Type_69(x+=+100,y:=20,w:=80,h:=35,Window:="MenuPecheAvance",Label:="DrawZonePeche",Text:="Afficher Zone",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))

HB_Button.Push(New Button_Type_69(x:=10,y:=85,w:=80,h:=35,Window:="MenuPecheAvance",Label:="ZoneVente",Text:="Delimiter une zone",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Button_Type_69(x+=+100,y:=85,w:=80,h:=35,Window:="MenuPecheAvance",Label:="DrawZoneVente",Text:="Afficher Zone",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))

HB_Button.Push(New Button_Type_69(x:=57,y:=155,w:=90,h:=22,Window:="MenuPecheAvance",Label:="Save",Text:="Sauvegarder",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))


Gui, Font, s8 bold, Comfortaa
Gui, MenuPecheAvance:Add, Text, x15  y148    w170   h1    0x4
Gui, MenuPecheAvance:Add, Text, x15  y60   w170   h1    0x4
Gui, MenuPecheAvance:add,Button,x15  y45    w170   h1 hide

Gui, MenuPecheAvance:Color,00FF00
WinSet, Transcolor , 00FF00
Gui,MenuPecheAvance:show,x144 y47 h180 w200

return




;#####################################################################################
;                               MENU PARAMETRE
;#####################################################################################




MenuParametre:
If MenuParametreShow=1
    return
ResetMenu()
If MenuParametreShow=0
    DeleteGui()
MenuParametreShow=1

Gui, MenuParametre:new
Gui, +hwndMenuParametre +ToolWindow -Caption +Parent1 +lastfound
HB_Button.Push(New Message(x:=45,y:=0,w:=105,h:=15,Window:="MenuParametre",Label:="",Text:="Source Audio",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Message(x:=45,y:=45,w:=105,h:=15,Window:="MenuParametre",Label:="",Text:="Raccourcis",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Message(x:=20,y:=60,w:=65,h:=15,Window:="MenuParametre",Label:="",Text:="Monture",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Message(x:=120,y:=60,w:=65,h:=15,Window:="MenuParametre",Label:="",Text:="Appats",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Message(x:=20,y:=104,w:=65,h:=15,Window:="MenuParametre",Label:="",Text:="Peche",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Message(x:=120,y:=104,w:=65,h:=15,Window:="MenuParametre",Label:="",Text:="Stop Bot",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
HB_Button.Push(New Button_Type_69(x:=57,y:=155,w:=90,h:=22,Window:="MenuParametre",Label:="SaveParametre",Text:="Sauvegarder",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))

Gui, MenuParametre:add,hotkey,x30 y80 w46 h20  gHotkeyMonture vHotkeyMonture Limit128, %HotkeyMonture%
Gui, MenuParametre:add,hotkey,x130 y80 w46 h20 gHotkeyAppats vHotkeyAppats, %HotkeyAppats%
Gui, MenuParametre:add,hotkey,x30 y124  w46 h20 center gHotkeyCanne vHotkeyCanne, %HotkeyCanne%
Gui, MenuParametre:add,hotkey,x130 y124  w46 h20 center gHotkeySTOP hwndHotkeyStop vHotkeySTOP, %HotkeySTOP%


Gui,MenuParametre:add,Button,x0  y0    w170   h1 hide vHIDEBUTTON
Gui, MenuParametre:Add, dropdownlist,x10 y18 w180 h1 r15 hwndDDL vSelectAudio gAudio , %devlist%
Gui, MenuParametre:Add, Text, x15 y43 w170   h1    0x4
Gui, MenuParametre:Add, Text, x15  y148 w170   h1    0x4
Gui,MenuParametre:Color,00FF00
WinSet, Transcolor , 00FF00
Gui, MenuParametre:show,x144 y47 h180 w200
GuiControl, MenuParametre:ChooseString, SelectAudio, %SelectAudio%
Gui, Submit, NoHide
CtlColors.Attach(DDL, "silver","purple")
return



;#####################################################################################
;                                MENU VERSION
;#####################################################################################


MenuVersion:
If MenuVersionShow=1
    return
ResetMenu()
If MenuVersionShow=0
    DeleteGui()
MenuVersionShow=1

Gui, MenuVersion:new
Gui,+hwndMenuVersion +ToolWindow -Caption +Parent1 +lastfound
HB_Button.Push(New Message(x:=0,y:=0,w:=200,h:=180,Window:="MenuVersion",Label:="",Text:="Patch Notes`n`n+ Ajout Menu Peche`n`n+ Ajout Menu Avancee`n`n+ Ajout Selecteur Zone`n`n+ Ajout Hotkey Mont/Peche/Appats`n`n+ Ajout Sauvegarde",Font:="Arial",Font_Size:="12 Bold",Font_Color_Top:="BF5205",Font_Color_Bottom:="FFFFFF",Button_Background_Color,RoundNess:=2))
Gui,MenuVersion:Color,00FF00
WinSet, Transcolor, 00FF00
Gui,MenuVersion:show,x144 y47 h180 w200
return




;#####################################################################################
;                                label
;#####################################################################################


OnOff:
if onoff=1
{
OnOff()
}
return


HotkeySTOP:
HotkeyAssign()
GuiControl, MenuParametre:focus, HIDEBUTTON
return
HotkeyMonture:
GuiControl, MenuParametre:focus, HIDEBUTTON
return
HotkeyAppats:
GuiControl, MenuParametre:focus, HIDEBUTTON
return
HotkeyCanne:
GuiControl, MenuParametre:focus, HIDEBUTTON
return
;HB_Switch[2]

BotPecheOff:
Onoff()
return
BotPeche:
If (OnOff=0)
{
Onoff()
}

VerifWoW()
if (WowAbs=1)
    return
WinMinimize, Connector
x1F=%xCoordPeche%
y1F=%yCoordPeche%
x2F:=(xCoordPeche + wCoordPeche)
y2F:=(yCoordPeche + hCoordPeche)
PecheWow()
return

SaveParametre:
VerifWoW()
if (WowAbs=1)
    return
IniWrite, %HotkeyMonture% ,Setting.ini, Raccourcis , Monture
IniWrite, %HotkeyAppats% ,Setting.ini, Raccourcis , Appats
IniWrite, %HotkeyCanne% ,Setting.ini, Raccourcis , Canne
IniWrite, %HotkeySTOP% ,Setting.ini, Raccourcis , Stop
IniWrite, %audioSource1% ,Setting.ini, Audio , AudioSource
IniWrite, %SelectAudio% ,Setting.ini, Audio , SelectAudio
HotkeyAssign()
return


Audio:
Gui, Submit, NoHide
SelectAudio := SelectAudio
StringSplit, audioSource, SelectAudio, ":", .
GuiControl, MenuParametre:focus, HIDEBUTTON
return



Save:
VerifWoW()
if (WowAbs=1)
    return
IniWrite, %xCoordPeche% , Setting.ini,CoordZone,xCoordPeche
IniWrite, %yCoordPeche% , Setting.ini,CoordZone,yCoordPeche
IniWrite, %wCoordPeche% , Setting.ini,CoordZone,wCoordPeche
IniWrite, %hCoordPeche% , Setting.ini,CoordZone,hCoordPeche
IniWrite, %xCoordVente% , Setting.ini,CoordZone,xCoordVente
IniWrite, %yCoordVente% , Setting.ini,CoordZone,yCoordVente
IniWrite, %wCoordVente% , Setting.ini,CoordZone,wCoordVente
IniWrite, %hCoordVente% , Setting.ini,CoordZone,hCoordVente
goto MenuPeche
return




DrawZonePeche:
{
VerifWoW()
if (WowAbs=1)
    return
OnOffP := !OnOffP
If (OnOffP=1)
{
Gui, DrawP:destroy
x1F=%xCoordPeche%
y1F=%yCoordPeche%
x2F:=(xCoordPeche + wCoordPeche)
y2F:=(yCoordPeche + hCoordPeche)
color := 0x4d000000
Gui, DrawP: -Caption +E0x80000 +LastFound +AlwaysOnTop +ToolWindow +OwnDialogs ; Layered window
Gui, DrawP: Show, NA
hwnd1 := WinExist()
pToken := Gdip_Startup()
hbm    := CreateDIBSection(Width, Height)
hdc    := CreateCompatibleDC()
obm    := SelectObject(hdc, hbm)
G      := Gdip_GraphicsFromHDC(hdc)
Gdip_SetSmoothingMode(G, 4)
Brush := Gdip_BrushCreateSolid( "0xD90080FD" )
pPen   := Gdip_CreatePen(color, 10)
	Gdip_FillRectangle( G , Brush , x1f-5 , y1f-10 , wCoordPeche+10, 5 )    ;haut

    Gdip_FillRectangle( G , Brush , x1f-10 , y1f-10 , 5, hcoordPeche+20 )     ;gauche

    Gdip_FillRectangle( G , Brush , x2f+5 , y1f-10 , 5, hcoordPeche+20 )     ;droit

    Gdip_FillRectangle( G , Brush , x1f-5 , y2f+5 , wCoordPeche+10, 5 )   ;bas
	Gdip_DeleteBrush( Brush )
UpdateLayeredWindow(hwnd1, hdc, 0, 0, Width, Height)
Gdip_DeletePen(pPen), Gdip_DeleteBrush(hBrush)
SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc), Gdip_DeleteGraphics(G)
return
}
else
    Gui,DrawP:Destroy
}
return
ZonePeche:
{
VerifWoW()
if (WowAbs=1)
    return
WinMinimize, Connector
Gui, DrawP: -Caption +E0x80000 +LastFound +AlwaysOnTop +ToolWindow +OwnDialogs ; Layered window
Gui, DrawP: Show, NA
hwnd1 := WinExist()
hbm := CreateDIBSection(Width, Height)
hdc := CreateCompatibleDC()
obm := SelectObject(hdc, hbm)
G := Gdip_GraphicsFromHDC(hdc)
Gdip_SetSmoothingMode(G, 4)
pBrush := Gdip_BrushCreateSolid(0xaa000000)
Gdip_FillRoundedRectangle(G, pBrush, 0, 0, Width, Height, 20)
Gdip_DeleteBrush(pBrush)
Options = x10p y20p w80p Centre cffffffff r4 s50 Underline Italic
Gdip_TextToGraphics(G, "Appuyer sur ALT pour commencer a Delimiter une zone `n Faite un click gauche une fois fini.", Options, "Comfortaa", Width, Height)
UpdateLayeredWindow(hwnd1, hdc, (A_ScreenWidth-Width)//2, (A_ScreenHeight-Height)//2, Width, Height)
SelectObject(hdc, obm)
DeleteObject(hbm)
DeleteDC(hdc)
Gdip_DeleteGraphics(G)
WinActivate, World of Warcraft
WinWait, World of Warcraft,, A
KeyWait, Alt, D
Gui, DrawP:destroy
MouseGetPos, X1,Y1
Loop {
MouseGetPos, X2,Y2
xCoordPeche := x1, yCoordPeche := y1, wCoordPeche := x2-x1, hCoordPeche := y2-y1
color := 0x4d000000

Gui, DrawP: -Caption +E0x80000 +LastFound +AlwaysOnTop +ToolWindow +OwnDialogs ; Layered window
Gui, DrawP: Show, NA
hwnd1 := WinExist() ; The created window's handle

; Set up the bitmap
pToken := Gdip_Startup()
hbm    := CreateDIBSection(Width, Height)  ; The GDI bitmap
hdc    := CreateCompatibleDC()                         ; Device context compatible with screen
obm    := SelectObject(hdc, hbm)                       ; Select bitmap into device context
G      := Gdip_GraphicsFromHDC(hdc)                    ; Get pointer to graphics of bitmap
Gdip_SetSmoothingMode(G, 4)
Brush := Gdip_BrushCreateSolid( "0xFFFFFFFF" )
pPen   := Gdip_CreatePen(color, 10)
hBrush := Gdip_BrushCreateSolid(color)
Gdip_DrawRectangle(G, pPen,   xCoordPeche, yCoordPeche, wCoordPeche, hCoordPeche)
Gdip_FillRectangle(G, hBrush, xCoordPeche, yCoordPeche, wCoordPeche, hCoordPeche)
UpdateLayeredWindow(hwnd1, hdc, 0, 0, Width, Height)
Gdip_DeletePen(pPen), Gdip_DeleteBrush(hBrush)
SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc), Gdip_DeleteGraphics(G)
GetKeyState, state, LButton
if (state = "D")
{
    Gui, DrawP:destroy
    WinActivate, Connector
    break
}
}
}
return
DrawZoneVente:
{
VerifWoW()
if (WowAbs=1)
    return
OnOffV := !OnOffV
If (OnOffV=1)
{
Gui, Draw:destroy
x1F=%xCoordVente%
y1F=%yCoordVente%
x2F:=(xCoordVente + wCoordVente)
y2F:=(yCoordVente + hCoordVente)
color := 0x4d000000
Gui, DrawV: -Caption +E0x80000 +LastFound +AlwaysOnTop +ToolWindow +OwnDialogs ; Layered window
Gui, DrawV: Show, NA
hwnd1 := WinExist()
pToken := Gdip_Startup()
hbm    := CreateDIBSection(Width, Height)
hdc    := CreateCompatibleDC()
obm    := SelectObject(hdc, hbm)
G      := Gdip_GraphicsFromHDC(hdc)
Gdip_SetSmoothingMode(G, 4)
Brush := Gdip_BrushCreateSolid( "0xD900EF26" )
pPen   := Gdip_CreatePen(color, 10)
	Gdip_FillRectangle( G , Brush , x1f-5 , y1f-10 , wCoordVente+10, 5 )    ;haut

    Gdip_FillRectangle( G , Brush , x1f-10 , y1f-10 , 5, hcoordVente+20 )     ;gauche

    Gdip_FillRectangle( G , Brush , x2f+5 , y1f-10 , 5, hcoordVente+20 )     ;droit

    Gdip_FillRectangle( G , Brush , x1f-5 , y2f+5 , wCoordVente+10, 5 )   ;bas
	Gdip_DeleteBrush( Brush )
UpdateLayeredWindow(hwnd1, hdc, 0, 0, Width, Height)
Gdip_DeletePen(pPen), Gdip_DeleteBrush(hBrush)
SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc), Gdip_DeleteGraphics(G)
return
}
else
    Gui,DrawV:Destroy
}
return
ZoneVente:
{
VerifWoW()
if (WowAbs=1)
    return
WinMinimize, Connector
Gui, DrawV: -Caption +E0x80000 +LastFound +AlwaysOnTop +ToolWindow +OwnDialogs ; Layered window
Gui, DrawV: Show, NA
hwnd1 := WinExist()
hbm := CreateDIBSection(Width, Height)
hdc := CreateCompatibleDC()
obm := SelectObject(hdc, hbm)
G := Gdip_GraphicsFromHDC(hdc)
Gdip_SetSmoothingMode(G, 4)
pBrush := Gdip_BrushCreateSolid(0xaa000000)
Gdip_FillRoundedRectangle(G, pBrush, 0, 0, Width, Height, 20)
Gdip_DeleteBrush(pBrush)
Options = x10p y20p w80p Centre cffffffff r4 s50 Underline Italic
Gdip_TextToGraphics(G, "Appuyer sur ALT pour commencer a DÃ©limiter une zone `n Faite un click gauche une fois fini.", Options, "Comfortaa", Width, Height)
UpdateLayeredWindow(hwnd1, hdc, (A_ScreenWidth-Width)//2, (A_ScreenHeight-Height)//2, Width, Height)
SelectObject(hdc, obm)
DeleteObject(hbm)
DeleteDC(hdc)
Gdip_DeleteGraphics(G)
WinActivate, World of Warcraft
WinWait, World of Warcraft,, A
KeyWait, Alt, D
Gui, DrawV:destroy
MouseGetPos, X1,Y1
Loop {
MouseGetPos, X2,Y2
xCoordVente := x1, yCoordVente := y1, wCoordVente := x2-x1, hCoordVente := y2-y1
color := 0x4d000000

Gui, DrawV: -Caption +E0x80000 +LastFound +AlwaysOnTop +ToolWindow +OwnDialogs ; Layered window
Gui, DrawV: Show, NA
hwnd1 := WinExist() ; The created window's handle

; Set up the bitmap
pToken := Gdip_Startup()
hbm    := CreateDIBSection(Width, Height)  ; The GDI bitmap
hdc    := CreateCompatibleDC()                         ; Device context compatible with screen
obm    := SelectObject(hdc, hbm)                       ; Select bitmap into device context
G      := Gdip_GraphicsFromHDC(hdc)                    ; Get pointer to graphics of bitmap
Gdip_SetSmoothingMode(G, 4)
Brush := Gdip_BrushCreateSolid( "0xFFFFFFFF" )
pPen   := Gdip_CreatePen(color, 10)
hBrush := Gdip_BrushCreateSolid(color)
Gdip_DrawRectangle(G, pPen,   xCoordVente, yCoordVente, wCoordVente, hCoordVente)
Gdip_FillRectangle(G, hBrush, xCoordVente, yCoordVente, wCoordVente, hCoordVente)
UpdateLayeredWindow(hwnd1, hdc, 0, 0, Width, Height)
Gdip_DeletePen(pPen), Gdip_DeleteBrush(hBrush)
SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc), Gdip_DeleteGraphics(G)
GetKeyState, state, LButton
if (state = "D")
{
    Gui, DrawV:destroy
    WinActivate, Connector
    break
}
}
}
return

Return:
return


WinMinimize:
WinMinimize
return
Exit:
Gdip_Shutdown(pToken)
FileSetAttrib, -R, Main.ahk
FileDelete, Main.ahk
ExitApp




;#####################################################################################
;                                FONCTION
;#####################################################################################



HotkeyAssign(){
    global
If (HotkeySTOP="ERROR" or HotkeySTOP="")
{
HotkeySTOP=Escape
Hotkey,~%HotkeyStop%,OnOff
GuiControl,MenuParametre:,HotkeySTOP,%HotkeyStop%
}
else
{
    Hotkey,%HotkeyStop%,OnOff
}
}
OnOffVerif(){
    if OnOff=1
{
    GuiControl,hide,% HB_Button[6].hwnd
    GuiControl,show,% HB_Button[7].hwnd
   }
else
{
    GuiControl,hide,% HB_Button[7].hwnd
    GuiControl,show,% HB_Button[6].hwnd
   }
}
OnOff(){
    global
OnOff:=!OnOff
IfWinExist ahk_id %MenuPeche%
{
    WinActivate, Connector
    OnOffVerif()
}
}
DeleteGui(){
    global
    OnOff.removeAt(0,2)
    HB_Button.removeAt(5,50)
    Gui,MenuPeche:Destroy
    Gui,MenuVersion:Destroy
    Gui,MenuPecheAvance:Destroy
    Gui,MenuParametre:Destroy
}
ResetMenu(){
    global
    MenuParametreShow=0
    MenuPecheShow=0
    MenuPecheAvanceShow=0
    MenuVersionShow=0
}
VerifWow(){
    global
 IfWinNotExist, World of Warcraft
{
    MsgBox Veuillez lancer World of Warcraft
    WowAbs=1
}
}
PecheWow(){
  global
  resetx=x0
  resety=y500
  afk=0
send,{click}
sleep 1000
send, %HotkeyCanne%
MouseMove, %RESETx%, %RESETy%
Sleep 500
thiscursor1:=QueryMouseCursor()
Loop{
thiscursor:=QueryMouseCursor()
if (thiscursor=thiscursor1)
{
x1F+=0.5
	MouseMove,%x1F%,%y1F%
	if (x1F>=x2F)
	{
		y1F+=30
		x1F=%xCoordPeche%
	}
	if (y1F>=y2F)
	{
		y1F=%yCoordPeche%
        afk++
	}
    if (afk=3)
    {

        gosub BotPeche
    }
    If OnOff=0
    {
    ToolTip
    OnOffVerif()
    break
}
}
else
	break
}

sleep 1000
audioMeter := VA_GetAudioMeter(audioSource1)
VA_IAudioMeterInformation_GetMeteringChannelCount(audioMeter, 1)
VA_GetDevicePeriod("capture", devicePeriod)
Loop
{
        If OnOff=0
    {
    OnOffVerif()
    ToolTip
    break
    }
    ; Get the peak value across all channels.
    VA_IAudioMeterInformation_GetPeakValue(audioMeter, peakValue)
    meter := MakeMeter(peakValue, MeterLength)

    ; Get the peak values of all channels.
    VarSetCapacity(peakValues, channelCount*4)
    VA_IAudioMeterInformation_GetChannelsPeakValues(audioMeter, 1, &peakValues)
    Loop %channelCount%
        meter.= "" MakeMeter(NumGet(peakValues, A_Index*4-4, "float"), MeterLength)

    ToolTip, %meter% %StartTime% ,0,0
    Sleep, %devicePeriod%

   if (A_TimeIdle > 25000)
    {
    ToolTip
    gosub BotPeche
}
	if (meter>=0.20)
	{
    ToolTip
    sleep 1000
    gosub BotPeche
}
}
}

AppatsPoisson(){
    Send %HotkeyAppats%
    sleep 1000
}

MoveWin(){
	PostMessage,0xA1,2
}

SousMenu(){
	;Bitmap Created Using: HB Bitmap Maker
	pBitmap:=Gdip_CreateBitmap( 350 , 500 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	;BG MENU
	Brush := Gdip_BrushCreateSolid( "0xFF000000" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 203 , 186 , 5 )
	Gdip_DeleteBrush( Brush )
	;BG MENU
	Brush := Gdip_CreateLineBrush( 230 , 350 , 100 , 100 , "0xFF111111" , "0xFF222222" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 201 , 184 , 4 )
	Gdip_DeleteBrush( Brush )
	;Background
	Brush := Gdip_BrushCreateHatch( "0x4D000000" , "0x00000000" , 3 )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 201 , 234 , 9 )
	Gdip_DeleteBrush( Brush )
	Gdip_DeleteGraphics( G )
	return pBitmap
}

Back_Ground_HUD(){

	pBitmap:=Gdip_CreateBitmap( 350 , 500 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 9 )
	;Border
	Brush := Gdip_CreateLineBrush( 230 , 350 , 100 , 100 , "0xFF111111" , "0xFF222222" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 4 , 4 , 343 , 235 , 9 )
	Gdip_DeleteBrush( Brush )
	;Background
	Brush := Gdip_CreateLineBrushFromRect( 0 , 0 , 1 , 120 , "0xFF000000" , "0xFF6E0E2D" , 1 , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 5 , 5 , 341 , 233 , 9 )
	Gdip_DeleteBrush( Brush )
	;BG MENU
	Brush := Gdip_BrushCreateSolid( "0xFF000000" )
	Gdip_FillRoundedRectangle( G , Brush , 14 , 39 , 105 , 185 , 5 )
	Gdip_DeleteBrush( Brush )
	;BG MENU
	Brush := Gdip_CreateLineBrush( 230 , 350 , 100 , 100 , "0xFF111111" , "0xFF222222" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 15 , 40 , 103 , 183 , 4 )
	Gdip_DeleteBrush( Brush )
	;BG MENU
	Brush := Gdip_BrushCreateSolid( "0xFF000000" )
	Gdip_FillRoundedRectangle( G , Brush , 133 , 39 , 203 , 186 , 5 )
	Gdip_DeleteBrush( Brush )
	;BG MENU
	Brush := Gdip_CreateLineBrush( 230 , 350 , 100 , 100 , "0xFF111111" , "0xFF222222" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 134 , 40 , 201 , 184 , 4 )
	Gdip_DeleteBrush( Brush )
	;Background
	Brush := Gdip_BrushCreateHatch( "0x4D000000" , "0x00000000" , 3 )
	Gdip_FillRoundedRectangle( G , Brush , 5 , 5 , 341 , 234 , 9 )
	Gdip_DeleteBrush( Brush )
	;Login
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRoundedRectangle( G , Brush , 5 , 5 , 341 , 27 , 9 )
	Gdip_DeleteBrush( Brush )
	;Login
	Brush := Gdip_BrushCreateHatch( "0x66000000" , "0x00000000" , 2 )
	Gdip_FillRoundedRectangle( G , Brush , 5 , 5 , 341 , 27 , 9 )
	Gdip_DeleteBrush( Brush )
	;Login
	Brush := Gdip_CreateLineBrushFromRect( 2 , 45 , 1 , 30 , "0xFF000000" , "0xFF333333" , 1 , 1 )
	Gdip_FillRectangle( G , Brush , 5 , 17 , 341 , 15 )
	Gdip_DeleteBrush( Brush )
	;Login
	Brush := Gdip_BrushCreateHatch( "0x66000000" , "0x00333333" , 2 )
	Gdip_FillRectangle( G , Brush , 5 , 17 , 341 , 15 )
	Gdip_DeleteBrush( Brush )
	;Border login bot
	Brush := Gdip_BrushCreateSolid( "0xFF000000" )
	Gdip_FillRectangle( G , Brush , 5 , 32 , 341 , 1 )
	Gdip_DeleteBrush( Brush )
	;Login Launcher Title
	Brush := Gdip_BrushCreateSolid( "0xFFF0F0F0" )
	;Login Launcher Title
	Gdip_TextToGraphics( G , "CONNECTOR" , "s14  vCenter Bold c" Brush " x20 y11" , "Comfortaa" , 220 , 20 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_CreateLineBrush( 0 , 200 , 0 , 151 , "0xFF333333" , "0xFF252525" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 8 , 233 , 335 , 5 , 2 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF252525" )
	Gdip_FillRectangle( G , Brush , 6 , 233 , 340 , 3 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateHatch( "0x4D000000" , "0x00000000" , 2 )
	Gdip_FillRectangle( G , Brush , 6 , 233 , 340 , 3 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateHatch( "0x4d000000" , "0x0D000000" , 2 )
	Gdip_FillRoundedRectangle( G , Brush , 7 , 233 , 336 , 5 , 2 )
	Gdip_DeleteBrush( Brush )
	Gdip_DeleteGraphics( G )
	return pBitmap
}

class Button_Type_69	{
	__New(x:=10, y:=10, w:=90, h:=25, Window:="1", Label:="", Text:="Button", Font:="Arial", Font_Size:="10 Bold",Font_Color_Top:="000000",Font_Color_Bottom:="FFFFFF",Button_Background_Color:="F0F0F0",RoundNess:=2){
		This.X:=x
		This.Y:=y
		This.W:=w
		This.H:=h
		This.Window:=Window
		This.Label:=Label
		This.Text:=Text
		This.Font:=Font
		This.Font_Size:=Font_Size
		This.Font_Color_Top:= "0xFF" Font_Color_Top
		This.Font_Color_Bottom:= "0xFF" Font_Color_Bottom
		This.Button_Background_Color:="0xFF" Button_Background_Color
		This.Roundness:=Roundness

		This.Create_Trigger()
		This.Create_Default_Bitmap()
		This.Create_Hover_Bitmap()
		This.Create_Pressed_Bitmap()
		sleep,20
		This.Draw_Default()

	}
	Create_Trigger(){
		Gui,% This.Window ": Add",Picture,% "x" This.X " y" This.Y " w" This.W " h" This.H " hwndhwnd 0xE"
		This.Hwnd:=hwnd
		BPC:=This.Draw_Pressed.Bind(This)
		GuiControl,+G,% This.Hwnd,% BPC
		if(This.Label){
			(IsFunc(This.Label))?(This.Function:=Func(This.Label),This.Type:="Function"):(This.Type:="Label")
		}
	}
	Create_Default_Bitmap(){

	pBitmap:=Gdip_CreateBitmap( This.W+1 , This.H+1 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 5 )
	;BG
	Brush := Gdip_CreateLineBrush( 0 , 0 , 0 , 100 , "0xFF222222" , "0xFF222222" , 1 )
	Gdip_FillRectangle( G , Brush , -2 , -3 , 200 , 60 )
	Gdip_DeleteBrush( Brush )
	;border
	Brush := Gdip_BrushCreateSolid( "0xFFFFFFFF" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , This.W , This.H , 4 )
	Gdip_DeleteBrush( Brush )
	;fond button
	Brush := Gdip_BrushCreateSolid( "0xFF2A2A2A" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , This.W , This.H , 5 )
	Gdip_DeleteBrush( Brush )
	;texture
	Brush := Gdip_CreateLineBrush( 0 , 30 , 0 , 3 , "0xFF000000" , "0x1AFFFFFF" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , This.W , 4 , 1 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFFFFFFFF" )
	Gdip_TextToGraphics( G , This.Text , "s12 Center vCenter Bold c" Brush " x y" , "Comfortaa" , This.W , This.H+4 )
	Gdip_DeleteBrush( Brush )
	Gdip_DeleteGraphics( G )

		This.Default_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Create_Hover_Bitmap(){

	pBitmap:=Gdip_CreateBitmap( This.W+1 , This.H+1 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	Brush := Gdip_CreateLineBrush( 0 , 0 , 0 , 100 , "0xFF222222" , "0xFF222222" , 1 )
	Gdip_FillRectangle( G , Brush , -10 , -10 , 200 , 80 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFFAC1B34" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , This.W , This.H , 4 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , This.W , This.H , 5 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_CreateLineBrush( 0 , 30 , 0 , 3 , "0xFF000000" , "0x1AFFFFFF" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , This.W-1 , 4 , 1 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0x1A0078D7" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , This.W , This.H , 4 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFFFFFFFF" )
	Gdip_TextToGraphics( G , This.Text , "s12 Center vCenter Bold c" Brush " x y" , "Comfortaa" , This.W , This.H+4 )
	Gdip_DeleteBrush( Brush )
	Gdip_DeleteGraphics( G )


		This.Hover_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Create_Pressed_Bitmap(){

	pBitmap:=Gdip_CreateBitmap( This.W+1 , This.H+1 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	Brush := Gdip_CreateLineBrush( 0 , 0 , 0 , 50 , "0xFF222222" , "0xFF222222" , 1 )
	Gdip_FillRectangle( G , Brush , -10 , -12 , 200 , 70 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFFAC1B34" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , This.W , This.H , 4 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , This.W , This.H , 5 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_CreateLineBrush( 0 , 400 , 0 , 80 , "0xFF000000" , "0x33000000" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 0 , This.W , This.H , 5 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_CreateLineBrush( 0 , 30 , 0 , 3 , "0x66000000" , "0x66000000" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 2 , 0 , This.W-5 , 3 , 1 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_CreateLineBrush( 0 , 30 , 0 , 3 , "0x66000000" , "0x66000000" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 2 , This.H-4 , This.W-5 , 2 , 1 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFFFFFFFF" )
	Gdip_TextToGraphics( G , This.Text , "s11 Center vCenter Bold c" Brush " x y" , "Comfortaa" , This.W , This.H+4 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_CreateLineBrush( 0 , 30 , 0 , 3 , "0x66000000" , "0x66000000" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 2 , 2 , This.H-6 , 1 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_CreateLineBrush( 0 , 30 , 0 , 3 , "0x66000000" , "0x66000000" , 1 )
	Gdip_FillRoundedRectangle( G , Brush , This.W-3 , 2 , 2 , This.H-6 , 1 )
	Gdip_DeleteBrush( Brush )
	Gdip_DeleteGraphics( G )


		This.Pressed_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Draw_Pressed(){
		SetTimer,HB_Hover_Function,Off
		SetImage(This.hwnd, This.Pressed_Bitmap)
		While(GetKeyState("LButton"))
			Sleep,50
		SetTimer,HB_Hover_Function,On
		MouseGetPos,,,,ctrl,2
		if(ctrl=This.Hwnd){
			This.Draw_Hover()
			if(This.Type="Function"){
				This.Function.Call()
			}
			else if(This.Type:="Label")
				gosub,% This.Label
		}else
			This.Draw.Default()
	}
	Draw_Hover(){
		SetImage(This.hwnd, This.Hover_Bitmap)

	}
	Draw_Default(){
		SetImage(This.hwnd, This.Default_Bitmap)
	}
}

class Button_Type_Minimize	{
	__New(x:=10, y:=10, w:=90, h:=25, Window:="1", Label:="", Text:="Button", Font:="Arial", Font_Size:="10 Bold",Font_Color_Top:="000000",Font_Color_Bottom:="FFFFFF",Button_Background_Color:="F0F0F0",RoundNess:=2){
		This.X:=x
		This.Y:=y
		This.W:=w
		This.H:=h
		This.Window:=Window
		This.Label:=Label
		This.Text:=Text
		This.Font:=Font
		This.Font_Size:=Font_Size
		This.Font_Color_Top:= "0xFF" Font_Color_Top
		This.Font_Color_Bottom:= "0xFF" Font_Color_Bottom
		This.Button_Background_Color:="0xFF" Button_Background_Color
		This.Roundness:=Roundness

		This.Create_Trigger()
		This.Create_Default_Bitmap()
		This.Create_Hover_Bitmap()
		This.Create_Pressed_Bitmap()
		sleep,20
		This.Draw_Default()

	}
	Create_Trigger(){
		Gui,% This.Window ": Add",Picture,% "x" This.X " y" This.Y " w" This.W " h" This.H " hwndhwnd 0xE"
		This.Hwnd:=hwnd
		BPC:=This.Draw_Pressed.Bind(This)
		GuiControl,+G,% This.Hwnd,% BPC
		if(This.Label){
			(IsFunc(This.Label))?(This.Function:=Func(This.Label),This.Type:="Function"):(This.Type:="Label")
		}
	}
	Create_Default_Bitmap(){

	pBitmap:=Gdip_CreateBitmap( 15 , 15 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRectangle( G , Brush , -10 , -10 , 50 , 50 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF777777" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 15 , 15 , 3 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 1 , 13 , 13 , 4 )
	Gdip_DeleteBrush( Brush )
	Pen := Gdip_CreatePen( "0xFFFFFFFF" , 3 )
	Gdip_DrawLine( G , Pen , 4 , 7 , 11 , 7 )
	Gdip_DeletePen( Pen )
	Gdip_DeleteGraphics( G )

		This.Default_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Create_Hover_Bitmap(){

	pBitmap:=Gdip_CreateBitmap( 15 , 15 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRectangle( G , Brush , -10 , -10 , 50 , 50 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF777777" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 15 , 15 , 3 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 1 , 13 , 13 , 4 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0x4D0078D7" )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 1 , 13 , 13 , 4 )
	Gdip_DeleteBrush( Brush )
	Pen := Gdip_CreatePen( "0xFFFFFFFF" , 3 )
	Gdip_DrawLine( G , Pen , 4 , 7 , 11 , 7 )
	Gdip_DeletePen( Pen )
	Gdip_DeleteGraphics( G )

		This.Hover_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Create_Pressed_Bitmap(){

	pBitmap:=Gdip_CreateBitmap( 15 , 15 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRectangle( G , Brush , -10 , -10 , 50 , 50 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF777777" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 15 , 15 , 3 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF000000" )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 1 , 13 , 13 , 4 )
	Gdip_DeleteBrush( Brush )
	Pen := Gdip_CreatePen( "0xFFFFFFFF" , 3 )
	Gdip_DrawLine( G , Pen , 4 , 7 , 11 , 7 )
	Gdip_DeletePen( Pen )
	Gdip_DeleteGraphics( G )

		This.Pressed_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Draw_Pressed(){
		SetTimer,HB_Hover_Function,Off
		SetImage(This.hwnd, This.Pressed_Bitmap)
		While(GetKeyState("LButton"))
			Sleep,10
		SetTimer,HB_Hover_Function,On
		MouseGetPos,,,,ctrl,2
		if(ctrl=This.Hwnd){
			This.Draw_Hover()
			if(This.Type="Function"){
				This.Function.Call()
			}
			else if(This.Type:="Label")
				gosub,% This.Label
		}else
			This.Draw.Default()
	}
	Draw_Hover(){
		SetImage(This.hwnd, This.Hover_Bitmap)

	}
	Draw_Default(){
		SetImage(This.hwnd, This.Default_Bitmap)
	}
}

class Button_Type_Exit	{
	__New(x:=10, y:=10, w:=90, h:=25, Window:="1", Label:="", Text:="Button", Font:="Arial", Font_Size:="10 Bold",Font_Color_Top:="000000",Font_Color_Bottom:="FFFFFF",Button_Background_Color:="F0F0F0",RoundNess:=2){
		This.X:=x
		This.Y:=y
		This.W:=w
		This.H:=h
		This.Window:=Window
		This.Label:=Label
		This.Text:=Text
		This.Font:=Font
		This.Font_Size:=Font_Size
		This.Font_Color_Top:= "0xFF" Font_Color_Top
		This.Font_Color_Bottom:= "0xFF" Font_Color_Bottom
		This.Button_Background_Color:="0xFF" Button_Background_Color
		This.Roundness:=Roundness

		This.Create_Trigger()
		This.Create_Default_Bitmap()
		This.Create_Hover_Bitmap()
		This.Create_Pressed_Bitmap()
		sleep,20
		This.Draw_Default()

	}
	Create_Trigger(){
		Gui,% This.Window ": Add",Picture,% "x" This.X " y" This.Y " w" This.W " h" This.H " hwndhwnd 0xE"
		This.Hwnd:=hwnd
		BPC:=This.Draw_Pressed.Bind(This)
		GuiControl,+G,% This.Hwnd,% BPC
		if(This.Label){
			(IsFunc(This.Label))?(This.Function:=Func(This.Label),This.Type:="Function"):(This.Type:="Label")
		}
	}
	Create_Default_Bitmap(){

	pBitmap:=Gdip_CreateBitmap( 15 , 15 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRectangle( G , Brush , -10 , -10 , 50 , 50 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF777777" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 15 , 15 , 3 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 1 , 13 , 13 , 4 )
	Gdip_DeleteBrush( Brush )
	Pen := Gdip_CreatePen( "0xFFFFFFFF" , 2 )
	Gdip_DrawLine( G , Pen , 4 , 4 , 11 , 11 )
	Gdip_DeletePen( Pen )
	Pen := Gdip_CreatePen( "0xFFFFFFFF" , 2 )
	Gdip_DrawLine( G , Pen , 4 , 11 , 11 , 4 )
	Gdip_DeletePen( Pen )
	Gdip_DeleteGraphics( G )

		This.Default_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Create_Hover_Bitmap(){

	pBitmap:=Gdip_CreateBitmap( 15 , 15 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRectangle( G , Brush , -10 , -10 , 50 , 50 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF777777" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 15 , 15 , 3 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 1 , 13 , 13 , 4 )
	Gdip_DeleteBrush( Brush )
	Pen := Gdip_CreatePen( "0xFFFFFFFF" , 2 )
	Gdip_DrawLine( G , Pen , 4 , 4 , 11 , 11 )
	Gdip_DeletePen( Pen )
	Pen := Gdip_CreatePen( "0xFFFFFFFF" , 2 )
	Gdip_DrawLine( G , Pen , 4 , 11 , 11 , 4 )
	Gdip_DeletePen( Pen )
	Brush := Gdip_BrushCreateSolid( "0x66880000" )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 1 , 13 , 13 , 4 )
	Gdip_DeleteBrush( Brush )
	Gdip_DeleteGraphics( G )

		This.Hover_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Create_Pressed_Bitmap(){

	pBitmap:=Gdip_CreateBitmap( 15 , 15 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	Brush := Gdip_BrushCreateSolid( "0xFF333333" )
	Gdip_FillRectangle( G , Brush , -10 , -10 , 50 , 50 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF777777" )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 15 , 15 , 3 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFF000000" )
	Gdip_FillRoundedRectangle( G , Brush , 1 , 1 , 13 , 13 , 4 )
	Gdip_DeleteBrush( Brush )
	Pen := Gdip_CreatePen( "0xFFFFFFFF" , 2 )
	Gdip_DrawLine( G , Pen , 4 , 4 , 11 , 11 )
	Gdip_DeletePen( Pen )
	Pen := Gdip_CreatePen( "0xFFFFFFFF" , 2 )
	Gdip_DrawLine( G , Pen , 4 , 11 , 11 , 4 )
	Gdip_DeletePen( Pen )
	Gdip_DeleteGraphics( G )

		This.Pressed_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Draw_Pressed(){
		SetTimer,HB_Hover_Function,Off
		SetImage(This.hwnd, This.Pressed_Bitmap)
		While(GetKeyState("LButton"))
			Sleep,10
		SetTimer,HB_Hover_Function,On
		MouseGetPos,,,,ctrl,2
		if(ctrl=This.Hwnd){
			This.Draw_Hover()
			if(This.Type="Function"){
				This.Function.Call()
			}
			else if(This.Type:="Label")
				gosub,% This.Label
		}else
			This.Draw.Default()
	}
	Draw_Hover(){
		SetImage(This.hwnd, This.Hover_Bitmap)

	}
	Draw_Default(){
		SetImage(This.hwnd, This.Default_Bitmap)
	}
}

class Message	{
	__New(x:=10, y:=10, w:=90, h:=25, Window:="1", Label:="", Text:="Button", Font:="Arial", Font_Size:="10 Bold",Font_Color_Top:="000000",Font_Color_Bottom:="FFFFFF",Button_Background_Color:="F0F0F0",RoundNess:=2){
		This.X:=x
		This.Y:=y
		This.W:=w
		This.H:=h
		This.Window:=Window
		This.Label:=Label
		This.Text:=Text
		This.Font:=Font
		This.Font_Size:=Font_Size
		This.Font_Color_Top:= "0xFF" Font_Color_Top
		This.Font_Color_Bottom:= "0xFF" Font_Color_Bottom
		This.Button_Background_Color:="0xFF" Button_Background_Color
		This.Roundness:=Roundness

		This.Create_Trigger()
		This.Create_Default_Bitmap()
		This.Create_Hover_Bitmap()
		This.Create_Pressed_Bitmap()
		sleep,20
		This.Draw_Default()

	}
	Create_Trigger(){
		Gui,% This.Window ": Add",Picture,% "x" This.X " y" This.Y " w" This.W " h" This.H " hwndhwnd 0xE"
		This.Hwnd:=hwnd
		BPC:=This.Draw_Pressed.Bind(This)
		GuiControl,+G,% This.Hwnd,% BPC
		if(This.Label){
			(IsFunc(This.Label))?(This.Function:=Func(This.Label),This.Type:="Function"):(This.Type:="Label")
		}
	}
	Create_Default_Bitmap(){


	pBitmap:=Gdip_CreateBitmap( This.W+1 , This.H+1 )
	G := Gdip_GraphicsFromImage( pBitmap )
	Gdip_SetSmoothingMode( G , 4 )
	Brush := Gdip_CreateLineBrush( 0 , 400 , 0 , 80 , "0xFF1E1E1E" , "0xFF1E1E1E" , 2 )
	Gdip_FillRectangle( G , Brush , -1 , -1 , This.W+2 , This.H+2  )
 	Brush := Gdip_BrushCreateHatch( "0x4D000000" , "0x00000000" , 3 )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 341 , 234 , 9 )
	Gdip_DeleteBrush( Brush )
	Brush := Gdip_BrushCreateSolid( "0xFFFFFFFF" )
	Gdip_TextToGraphics( G , This.Text , "s" This.Font_Size " Center vCenter Bold c" Brush " x y" , "Comfortaa" , This.W , This.H+4)
	Gdip_DeleteBrush( Brush )
	Gdip_DeleteGraphics( G )


		This.Default_Bitmap:=Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Draw_Default(){
		SetImage(This.hwnd, This.Default_Bitmap)
	}
}

class Flat_Round_Switch_Type_1	{
	__New(x,y,w:=19,Text:="Text",Font:="Arial",FontSize:= "10 Bold" , FontColor:="FFFFFF" ,Window:="1",Background_Color:="0x000000",State:=0){
		This.State:=State
		This.X:=x
		This.Y:=y
		This.W:=270
		This.H:=16
		This.Text:=Text
		This.Font:=Font
		This.FontSize:=FontSize
		This.FontColor:= "0xFF" FontColor
		This.Background_Color:=Background_Color
		This.Window:=Window
		This.Create_Off_Bitmap()
		This.Create_On_Bitmap()
		This.Create_Trigger()
		sleep,20
		if(This.State)
			This.Draw_On()
		else
			This.Draw_Off()
	}
	Create_Trigger(){
		Gui , % This.Window ": Add" , Picture , % "x" This.X " y" This.Y " w" This.W " h" This.H " 0xE hwndhwnd"
		This.Hwnd:=hwnd
		BD := THIS.Switch_State.BIND( THIS )
		GUICONTROL +G , % This.Hwnd , % BD
	}
	Create_Off_Bitmap(){
		;Bitmap Created Using: HB Bitmap Maker
		pBitmap:=Gdip_CreateBitmap( This.W , This.H )
		 G := Gdip_GraphicsFromImage( pBitmap )
		Gdip_SetSmoothingMode( G , 2 )
		Brush := Gdip_BrushCreateSolid( "0xFF1E1E1E" )
		Gdip_FillRectangle( G , Brush , -1 , -1 , This.W+2 , 23 )
		Gdip_DeleteBrush( Brush )
 	Brush := Gdip_BrushCreateHatch( "0x4D000000" , "0x00000000" , 3 )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 341 , 234 , 9 )
	Gdip_DeleteBrush( Brush )

		Brush := Gdip_BrushCreateSolid( "0xFF262827" )
		Gdip_FillRoundedRectangle( G , Brush , 1 , 2 , 26 , 13 , 5 )
		Gdip_DeleteBrush( Brush )
		Brush := Gdip_BrushCreateSolid( "0xFF303334" )
		Gdip_FillRoundedRectangle( G , Brush , 2 , 3 , 24 , 11 , 5 )
		Gdip_DeleteBrush( Brush )
		Brush := Gdip_BrushCreateSolid( "0x8827282B" )
		Gdip_FillEllipse( G , Brush , 0 , 0 , 18 , 18 )
		Gdip_DeleteBrush( Brush )
		Brush := Gdip_BrushCreateSolid( "0xFF1A1C1F" )
		Gdip_FillEllipse( G , Brush , 0 , 0 , 17 , 17 )
		Gdip_DeleteBrush( Brush )
		Brush := Gdip_CreateLineBrushFromRect( 3 , 2 , 11 , 14 , "0xFF60646A" , "0xFF393B3F" , 1 , 1 )
		Gdip_FillEllipse( G , Brush , 1 , 1 , 15 , 15 )
		Gdip_DeleteBrush( Brush )
		Brush := Gdip_BrushCreateSolid( This.FontColor )
		Gdip_TextToGraphics( G , This.Text , "s" This.FontSize " vCenter c" Brush " x33 y2" , This.Font , This.W-33, This.H )
		Gdip_DeleteBrush( Brush )

		This.Off_Bitmap := Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Create_On_Bitmap(){
		;Bitmap Created Using: HB Bitmap Maker
		pBitmap:=Gdip_CreateBitmap( This.W , This.H )
		 G := Gdip_GraphicsFromImage( pBitmap )
		Gdip_SetSmoothingMode( G , 2 )
		Brush := Gdip_BrushCreateSolid( "0xFF1E1E1E" )
		Gdip_FillRectangle( G , Brush , -1 , -1 , This.W+2 , 23 )
		Gdip_DeleteBrush( Brush )

		Pen := Gdip_CreatePen( "0xFF1B1D1E" , 1 )
		Gdip_DrawRoundedRectangle( G , Pen , 1 , 2 , 26 , 13 , 5 )
		Gdip_DeletePen( Pen )
		;~ Brush := Gdip_BrushCreateSolid( "0xFF1C538A" )
 	Brush := Gdip_BrushCreateHatch( "0x4D000000" , "0x00000000" , 3 )
	Gdip_FillRoundedRectangle( G , Brush , 0 , 0 , 341 , 234 , 9 )
		Gdip_DeleteBrush( Brush )
		;~ Brush := Gdip_BrushCreateSolid( "0xFF2672B3" )
		Brush := Gdip_BrushCreateSolid( "0xFF661633" )
		;~ Brush := Gdip_BrushCreateSolid( "0xFFA866E2" )
		Gdip_FillRoundedRectangle( G , Brush , 2 , 3 , 23 , 11 , 4 )
		Gdip_DeleteBrush( Brush )
		Brush := Gdip_BrushCreateSolid( "0x8827282B" )
		Gdip_FillEllipse( G , Brush , 11 , 0 , 18 , 18 )
		Gdip_DeleteBrush( Brush )
		Brush := Gdip_BrushCreateSolid( "0xFF1A1C1F" )
		Gdip_FillEllipse( G , Brush , 11 , 0 , 17 , 17 )
		Gdip_DeleteBrush( Brush )
		Brush := Gdip_CreateLineBrushFromRect( 3 , 2 , 11 , 14 , "0xFF60646A" , "0xFF393B3F" , 1 , 1 )
		Gdip_FillEllipse( G , Brush , 12 , 1 , 15 , 15 )
		Gdip_DeleteBrush( Brush )
		Brush := Gdip_CreateLineBrushFromRect( 5 , 3 , 10 , 12 , "0xFF4D5055" , "0xFF36383B" , 1 , 1 )
		Gdip_FillEllipse( G , Brush , 13 , 2 , 13 , 13 )
		Gdip_DeleteBrush( Brush )
        Brush := Gdip_BrushCreateSolid( This.FontColor )
		Gdip_TextToGraphics( G , This.Text , "s" This.FontSize " vCenter c" Brush " x33 y2" , This.Font , This.W-33, This.H )
		Gdip_DeleteBrush( Brush )
		This.On_Bitmap := Gdip_CreateHBITMAPFromBitmap(pBitmap)
		Gdip_DisposeImage(pBitmap)
	}
	Switch_State(){
		(This.State:=!This.State)?(This.Draw_On()):(This.Draw_Off())
		;~ This.State:=!This.State
		;~ If(This.State)
			;~ This.Draw_On()
		;~ else
			;~ This.Draw_Off()
	}
	Draw_Off(){
		SetImage( This.Hwnd , This.Off_Bitmap )
	}
	Draw_On(){
		SetImage( This.Hwnd , This.On_Bitmap )
	}
}


HB_Hover_Function(){
	static Hover_On, Index
	MouseGetPos,,,,ctrl,2
	if( ! Hover_On && ctrl){
		loop,% HB_Button.Length()
			if(ctrl=HB_Button[A_Index].Hwnd)
				HB_Button[A_Index].Draw_Hover(),Hover_On:=1,Index:=A_Index,break
	}else if(Hover_On)
		if( ctrl != HB_Button[Index].Hwnd)
			HB_Button[Index].Draw_Default(),Hover_On:=0
}


QueryMouseCursor()
{
	NumPut(VarSetCapacity(CurrentCursorStruct, A_PtrSize + 16), CurrentCursorStruct, "uInt")
	DllCall("GetCursorInfo", "ptr", &CurrentCursorStruct)
	return (numP:=NumGet(CurrentCursorStruct,  8))
}
	MakeMeter(fraction, size)
{
    global MeterLength
    Loop % fraction*size
        meter .= "|"
    Loop % (1-fraction)*size
        meter .= "."
    meter .= "  " fraction
    return meter
}







;##########################################################################################################################################################################
;########################################################################################################################################################################## VA - TRACKER SOUND
;##########################################################################################################################################################################
VA_GetAudioMeter(device_desc="playback")
{
    if ! device := VA_GetDevice(device_desc)
        return 0
    VA_IMMDevice_Activate(device, "{C02216F6-8C67-4B5B-9D00-D008E73E0064}", 7, 0, audioMeter)
    ObjRelease(device)
    return audioMeter
}
VA_IAudioMeterInformation_GetMeteringChannelCount(this, ByRef ChannelCount) {
    return DllCall(NumGet(NumGet(this+0)+4*A_PtrSize), "ptr", this, "uint*", ChannelCount)
}
VA_GetDevicePeriod(device_desc, ByRef default_period, ByRef minimum_period="")
{
    defaultPeriod := minimumPeriod := 0
    if ! device := VA_GetDevice(device_desc)
        return false
    VA_IMMDevice_Activate(device, "{1CB9AD4C-DBFA-4c32-B178-C2F568A703B2}", 7, 0, audioClient)
    ObjRelease(device)
    ; IAudioClient::GetDevicePeriod
    DllCall(NumGet(NumGet(audioClient+0)+9*A_PtrSize), "ptr",audioClient, "int64*",default_period, "int64*",minimum_period)
    ; Convert 100-nanosecond units to milliseconds.
    default_period /= 10000
    minimum_period /= 10000
    ObjRelease(audioClient)
    return true
}
VA_IAudioMeterInformation_GetPeakValue(this, ByRef Peak) {
    return DllCall(NumGet(NumGet(this+0)+3*A_PtrSize), "ptr", this, "float*", Peak)
}
VA_IAudioMeterInformation_GetChannelsPeakValues(this, ChannelCount, PeakValues) {
    return DllCall(NumGet(NumGet(this+0)+5*A_PtrSize), "ptr", this, "uint", ChannelCount, "ptr", PeakValues)
}
VA_GetDevice(device_desc="playback")
{
    static CLSID_MMDeviceEnumerator := "{BCDE0395-E52F-467C-8E3D-C4579291692E}"
        , IID_IMMDeviceEnumerator := "{A95664D2-9614-4F35-A746-DE8DB63617E6}"
    if !(deviceEnumerator := ComObjCreate(CLSID_MMDeviceEnumerator, IID_IMMDeviceEnumerator))
        return 0

    device := 0

    if VA_IMMDeviceEnumerator_GetDevice(deviceEnumerator, device_desc, device) = 0
        goto VA_GetDevice_Return

    if device_desc is integer
    {
        m2 := device_desc
        if m2 >= 4096 ; Probably a device pointer, passed here indirectly via VA_GetAudioMeter or such.
        {
            ObjAddRef(device := m2)
            goto VA_GetDevice_Return
        }
    }
    else
        RegExMatch(device_desc, "(.*?)\s*(?::(\d+))?$", m)

    if m1 in playback,p
        m1 := "", flow := 0 ; eRender
    else if m1 in capture,c
        m1 := "", flow := 1 ; eCapture
    else if (m1 . m2) = ""  ; no name or number specified
        m1 := "", flow := 0 ; eRender (default)
    else
        flow := 2 ; eAll

    if (m1 . m2) = ""   ; no name or number (maybe "playback" or "capture")
    {
        VA_IMMDeviceEnumerator_GetDefaultAudioEndpoint(deviceEnumerator, flow, 0, device)
        goto VA_GetDevice_Return
    }

    VA_IMMDeviceEnumerator_EnumAudioEndpoints(deviceEnumerator, flow, 1, devices)

    if m1 =
    {
        VA_IMMDeviceCollection_Item(devices, m2-1, device)
        goto VA_GetDevice_Return
    }

    VA_IMMDeviceCollection_GetCount(devices, count)
    index := 0
    Loop % count
        if VA_IMMDeviceCollection_Item(devices, A_Index-1, device) = 0
            if InStr(VA_GetDeviceName(device), m1) && (m2 = "" || ++index = m2)
                goto VA_GetDevice_Return
            else
                ObjRelease(device), device:=0

VA_GetDevice_Return:
    ObjRelease(deviceEnumerator)
    if devices
        ObjRelease(devices)

    return device ; may be 0
}
VA_IMMDevice_Activate(this, iid, ClsCtx, ActivationParams, ByRef Interface) {
    return DllCall(NumGet(NumGet(this+0)+3*A_PtrSize), "ptr", this, "ptr", VA_GUID(iid), "uint", ClsCtx, "uint", ActivationParams, "ptr*", Interface)
}
VA_IMMDeviceEnumerator_GetDevice(this, id, ByRef Device) {
    return DllCall(NumGet(NumGet(this+0)+5*A_PtrSize), "ptr", this, "wstr", id, "ptr*", Device)
}
VA_IMMDeviceEnumerator_GetDefaultAudioEndpoint(this, DataFlow, Role, ByRef Endpoint) {
    return DllCall(NumGet(NumGet(this+0)+4*A_PtrSize), "ptr", this, "int", DataFlow, "int", Role, "ptr*", Endpoint)
}
VA_IMMDeviceEnumerator_EnumAudioEndpoints(this, DataFlow, StateMask, ByRef Devices) {
    return DllCall(NumGet(NumGet(this+0)+3*A_PtrSize), "ptr", this, "int", DataFlow, "uint", StateMask, "ptr*", Devices)
}
VA_IMMDeviceCollection_Item(this, Index, ByRef Device) {
    return DllCall(NumGet(NumGet(this+0)+4*A_PtrSize), "ptr", this, "uint", Index, "ptr*", Device)
}
VA_IMMDeviceCollection_GetCount(this, ByRef Count) {
    return DllCall(NumGet(NumGet(this+0)+3*A_PtrSize), "ptr", this, "uint*", Count)
}
VA_GetDeviceName(device)
{
    static PKEY_Device_FriendlyName
    if !VarSetCapacity(PKEY_Device_FriendlyName)
        VarSetCapacity(PKEY_Device_FriendlyName, 20)
        ,VA_GUID(PKEY_Device_FriendlyName :="{A45C254E-DF1C-4EFD-8020-67D146A850E0}")
        ,NumPut(14, PKEY_Device_FriendlyName, 16)
    VarSetCapacity(prop, 16)
    VA_IMMDevice_OpenPropertyStore(device, 0, store)
    ; store->GetValue(.., [out] prop)
    DllCall(NumGet(NumGet(store+0)+5*A_PtrSize), "ptr", store, "ptr", &PKEY_Device_FriendlyName, "ptr", &prop)
    ObjRelease(store)
    VA_WStrOut(deviceName := NumGet(prop,8))
    return deviceName
}
VA_GUID(ByRef guid_out, guid_in="%guid_out%") {
    if (guid_in == "%guid_out%")
        guid_in :=   guid_out
    if  guid_in is integer
        return guid_in
    VarSetCapacity(guid_out, 16, 0)
	DllCall("ole32\CLSIDFromString", "wstr", guid_in, "ptr", &guid_out)
	return &guid_out
}
VA_IMMDevice_OpenPropertyStore(this, Access, ByRef Properties) {
    return DllCall(NumGet(NumGet(this+0)+4*A_PtrSize), "ptr", this, "uint", Access, "ptr*", Properties)
}
VA_WStrOut(ByRef str) {
    str := StrGet(ptr := str, "UTF-16")
    DllCall("ole32\CoTaskMemFree", "ptr", ptr)  ; FREES THE STRING.
}






;#####################################################################################
;Color
;#####################################################################################

Class CtlColors {
   Static Attached := {}
   Static HandledMessages := {Edit: 0, ListBox: 0, Static: 0}
   MessageHandlerFn := this.OnMessage.Bind(this)
   Static WM_CTLCOLOR := {Edit: 0x0133, ListBox: 0x134, Static: 0x0138}
   Static HTML := {AQUA: 0xFFFF00, BLACK: 0x000000, BLUE: 0xFF0000, FUCHSIA: 0xFF00FF, GRAY: 0x808080, GREEN: 0x008000
                 , LIME: 0x00FF00, MAROON: 0x000080, NAVY: 0x800000, OLIVE: 0x008080, PURPLE: 0x800080, RED: 0x0000FF
                 , SILVER: 0xC0C0C0, TEAL: 0x808000, WHITE: 0xFFFFFF, YELLOW: 0x00FFFF}
   Static SYSCOLORS := {Edit: "", ListBox: "", Static: ""}
   Static ErrorMsg := ""
   Static InitClass := CtlColors.ClassInit()

   __New() { ; You must not instantiate this class!
      If (This.InitClass == "!DONE!") { ; external call after class initialization
         This["!Access_Denied!"] := True
         Return False
      }
   }
   ; ----------------------------------------------------------------------------------------------------------------
   __Delete() {
      If This["!Access_Denied!"]
         Return
      This.Free() ; free GDI resources
   }

   ClassInit() {
      CtlColors := New CtlColors
      Return "!DONE!"
   }

   CheckBkColor(ByRef BkColor, Class) {
      This.ErrorMsg := ""
      If (BkColor != "") && !This.HTML.HasKey(BkColor) && !RegExMatch(BkColor, "^[[:xdigit:]]{6}$") {
         This.ErrorMsg := "Invalid parameter BkColor: " . BkColor
         Return False
      }
      BkColor := BkColor = "" ? This.SYSCOLORS[Class]
              :  This.HTML.HasKey(BkColor) ? This.HTML[BkColor]
              :  "0x" . SubStr(BkColor, 5, 2) . SubStr(BkColor, 3, 2) . SubStr(BkColor, 1, 2)
      Return True
   }

   CheckTxColor(ByRef TxColor) {
      This.ErrorMsg := ""
      If (TxColor != "") && !This.HTML.HasKey(TxColor) && !RegExMatch(TxColor, "i)^[[:xdigit:]]{6}$") {
         This.ErrorMsg := "Invalid parameter TextColor: " . TxColor
         Return False
      }
      TxColor := TxColor = "" ? ""
              :  This.HTML.HasKey(TxColor) ? This.HTML[TxColor]
              :  "0x" . SubStr(TxColor, 5, 2) . SubStr(TxColor, 3, 2) . SubStr(TxColor, 1, 2)
      Return True
   }

   Attach(HWND, BkColor, TxColor := "") {
      ; Names of supported classes
      Static ClassNames := {Button: "", ComboBox: "", Edit: "", ListBox: "", Static: ""}
      ; Button styles
      Static BS_CHECKBOX := 0x2, BS_RADIOBUTTON := 0x8
      ; Editstyles
      Static ES_READONLY := 0x800
      ; Default class background colors
      Static COLOR_3DFACE := 15, COLOR_WINDOW := 5
      ; Initialize default background colors on first call -------------------------------------------------------------
      If (This.SYSCOLORS.Edit = "") {
         This.SYSCOLORS.Static := DllCall("User32.dll\GetSysColor", "Int", COLOR_3DFACE, "UInt")
         This.SYSCOLORS.Edit := DllCall("User32.dll\GetSysColor", "Int", COLOR_WINDOW, "UInt")
         This.SYSCOLORS.ListBox := This.SYSCOLORS.Edit
      }
      This.ErrorMsg := ""
      ; Check colors ---------------------------------------------------------------------------------------------------
      If (BkColor = "") && (TxColor = "") {
         This.ErrorMsg := "Both parameters BkColor and TxColor are empty!"
         Return False
      }
      ; Check HWND -----------------------------------------------------------------------------------------------------
      If !(CtrlHwnd := HWND + 0) || !DllCall("User32.dll\IsWindow", "UPtr", HWND, "UInt") {
         This.ErrorMsg := "Invalid parameter HWND: " . HWND
         Return False
      }
      If This.Attached.HasKey(HWND) {
         This.ErrorMsg := "Control " . HWND . " is already registered!"
         Return False
      }
      Hwnds := [CtrlHwnd]
      ; Check control's class ------------------------------------------------------------------------------------------
      Classes := ""
      WinGetClass, CtrlClass, ahk_id %CtrlHwnd%
      This.ErrorMsg := "Unsupported control class: " . CtrlClass
      If !ClassNames.HasKey(CtrlClass)
         Return False
      ControlGet, CtrlStyle, Style, , , ahk_id %CtrlHwnd%
      If (CtrlClass = "Edit")
         Classes := ["Edit", "Static"]
      Else If (CtrlClass = "Button") {
         IF (CtrlStyle & BS_RADIOBUTTON) || (CtrlStyle & BS_CHECKBOX)
            Classes := ["Static"]
         Else
            Return False
      }
      Else If (CtrlClass = "ComboBox") {
         VarSetCapacity(CBBI, 40 + (A_PtrSize * 3), 0)
         NumPut(40 + (A_PtrSize * 3), CBBI, 0, "UInt")
         DllCall("User32.dll\GetComboBoxInfo", "Ptr", CtrlHwnd, "Ptr", &CBBI)
         Hwnds.Insert(NumGet(CBBI, 40 + (A_PtrSize * 2, "UPtr")) + 0)
         Hwnds.Insert(Numget(CBBI, 40 + A_PtrSize, "UPtr") + 0)
         Classes := ["Edit", "Static", "ListBox"]
      }
      If !IsObject(Classes)
         Classes := [CtrlClass]
      ; Check background color -----------------------------------------------------------------------------------------
      If !This.CheckBkColor(BkColor, Classes[1])
         Return False
      ; Check text color -----------------------------------------------------------------------------------------------
      If !This.CheckTxColor(TxColor)
         Return False
      ; Activate message handling on the first call for a class --------------------------------------------------------
      For I, V In Classes {
         If (This.HandledMessages[V] = 0)
            OnMessage(This.WM_CTLCOLOR[V], This.MessageHandlerFn)
         This.HandledMessages[V] += 1
      }
      ; Store values for HWND ------------------------------------------------------------------------------------------
      Brush := DllCall("Gdi32.dll\CreateSolidBrush", "UInt", BkColor, "UPtr")
      For I, V In Hwnds
         This.Attached[V] := {Brush: Brush, TxColor: TxColor, BkColor: BkColor, Classes: Classes, Hwnds: Hwnds}
      ; Redraw control -------------------------------------------------------------------------------------------------
      DllCall("User32.dll\InvalidateRect", "Ptr", HWND, "Ptr", 0, "Int", 1)
      This.ErrorMsg := ""
      Return True
   }

   Change(HWND, BkColor, TxColor := "") {
      ; Check HWND -----------------------------------------------------------------------------------------------------
      This.ErrorMsg := ""
      HWND += 0
      If !This.Attached.HasKey(HWND)
         Return This.Attach(HWND, BkColor, TxColor)
      CTL := This.Attached[HWND]
      ; Check BkColor --------------------------------------------------------------------------------------------------
      If !This.CheckBkColor(BkColor, CTL.Classes[1])
         Return False
      ; Check TxColor ------------------------------------------------------------------------------------------------
      If !This.CheckTxColor(TxColor)
         Return False
      ; Store Colors ---------------------------------------------------------------------------------------------------
      If (BkColor <> CTL.BkColor) {
         If (CTL.Brush) {
            DllCall("Gdi32.dll\DeleteObject", "Prt", CTL.Brush)
            This.Attached[HWND].Brush := 0
         }
         Brush := DllCall("Gdi32.dll\CreateSolidBrush", "UInt", BkColor, "UPtr")
         For I, V In CTL.Hwnds {
            This.Attached[V].Brush := Brush
            This.Attached[V].BkColor := BkColor
         }
      }
      For I, V In Ctl.Hwnds
         This.Attached[V].TxColor := TxColor
      This.ErrorMsg := ""
      DllCall("User32.dll\InvalidateRect", "Ptr", HWND, "Ptr", 0, "Int", 1)
      Return True
   }

   Detach(HWND) {
      This.ErrorMsg := ""
      HWND += 0
      If This.Attached.HasKey(HWND) {
         CTL := This.Attached[HWND].Clone()
         If (CTL.Brush)
            DllCall("Gdi32.dll\DeleteObject", "Prt", CTL.Brush)
         For I, V In CTL.Classes {
            If This.HandledMessages[V] > 0 {
               This.HandledMessages[V] -= 1
               If This.HandledMessages[V] = 0
                  OnMessage(This.WM_CTLCOLOR[V], this.MessageHandlerFn, 0)
         }  }
         For I, V In CTL.Hwnds
            This.Attached.Remove(V, "")
         DllCall("User32.dll\InvalidateRect", "Ptr", HWND, "Ptr", 0, "Int", 1)
         CTL := ""
         Return True
      }
      This.ErrorMsg := "Control " . HWND . " is not registered!"
      Return False
   }

   Free() {
      For K, V In This.Attached
         DllCall("Gdi32.dll\DeleteObject", "Ptr", V.Brush)
      For K, V In This.HandledMessages
         If (V > 0) {
            OnMessage(This.WM_CTLCOLOR[K], this.MessageHandlerFn, 0)
            This.HandledMessages[K] := 0
         }
      This.Attached := {}
      Return True
   }

   IsAttached(HWND) {
      Return This.Attached.HasKey(HWND)
   }


	OnMessage(HDC, HWND) {
	   Critical
	   If this.IsAttached(HWND) {
		  CTL := this.Attached[HWND]
		  If (CTL.TxColor != "")
			 DllCall("Gdi32.dll\SetTextColor", "Ptr", HDC, "UInt", CTL.TxColor)
		  DllCall("Gdi32.dll\SetBkColor", "Ptr", HDC, "UInt", CTL.BkColor)
		  Return CTL.Brush
	   }
	}

}

;#####################################################################################
;GDIP HELPER
;#####################################################################################


JustTheBasics() {
	global

	; Start gdi+
	If !pToken := Gdip_Startup()
	{
		MsgBox, 48, gdiplus error!, Gdiplus failed to start. Please ensure you have gdiplus on your system
		ExitApp
	}
	OnExit, Exite
	return


	Exite:
	; gdi+ may now be shutdown on exiting the program
	Gdip_Shutdown(pToken)
	ExitApp
	Return

}

SetUpGDIP(iWidth=-1, iHeight=-1) {
	global
	Width := iWidth
	Height := iHeight
	If (iWidth < 0) {
		Width := A_ScreenWidth
	}
	if (iHeight < 0) {
		height := A_ScreenHeight
	}


	JustTheBasics()

	; Create a layered window (+E0x80000 : must be used for UpdateLayeredWindow to work!) that is always on top (+AlwaysOnTop), has no taskbar entry or caption
	Gui, 1: -Caption +E0x80000 +LastFound +AlwaysOnTop +ToolWindow +OwnDialogs

	; Show the window
	Gui, 1: Show, NA

	; Get a handle to this window we have created in order to update it later
    hwnd1 := WinExist()
	return
}

StartDrawGDIP() {
	global

	; Create a gdi bitmap with width and height of what we are going to draw into it. This is the entire drawing area for everything
	hbm := CreateDIBSection(Width, Height)

	; Get a device context compatible with the screen
	hdc := CreateCompatibleDC()

	; Select the bitmap into the device context
	obm := SelectObject(hdc, hbm)

	; Get a pointer to the graphics of the bitmap, for use with drawing functions
	G := Gdip_GraphicsFromHDC(hdc)
}

EndDrawGDIP() {
	global

	; Update the specified window we have created (hwnd1) with a handle to our bitmap (hdc), specifying the x,y,w,h we want it positioned on our screen
	; So this will position our gui at (0,0) with the Width and Height specified earlier
	UpdateLayeredWindow(hwnd1, hdc, 0, 0, Width, Height)


	; Select the object back into the hdc
	SelectObject(hdc, obm)

	; Now the bitmap may be deleted
	DeleteObject(hbm)

	; Also the device context related to the bitmap may be deleted
	DeleteDC(hdc)

	; The graphics may now be deleted
	Gdip_DeleteGraphics(G)
}

ClearDrawGDIP() {
	global
	Gdip_GraphicsClear(G)
}

UpdateLayeredWindow(hwnd, hdc, x="", y="", w="", h="", Alpha=255)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    if ((x != "") && (y != ""))
        VarSetCapacity(pt, 8), NumPut(x, pt, 0, "UInt"), NumPut(y, pt, 4, "UInt")

    if (w = "") ||(h = "")
        WinGetPos,,, w, h, ahk_id %hwnd%

    return DllCall("UpdateLayeredWindow"
                    , Ptr, hwnd
                    , Ptr, 0
                    , Ptr, ((x = "") && (y = "")) ? 0 : &pt
                    , "int64*", w|h<<32
                    , Ptr, hdc
                    , "int64*", 0
                    , "uint", 0
                    , "UInt*", Alpha<<16|1<<24
                    , "uint", 2)
}


BitBlt(ddc, dx, dy, dw, dh, sdc, sx, sy, Raster="")
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdi32\BitBlt"
                    , Ptr, dDC
                    , "int", dx
                    , "int", dy
                    , "int", dw
                    , "int", dh
                    , Ptr, sDC
                    , "int", sx
                    , "int", sy
                    , "uint", Raster ? Raster : 0x00CC0020)
}


StretchBlt(ddc, dx, dy, dw, dh, sdc, sx, sy, sw, sh, Raster="")
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdi32\StretchBlt"
                    , Ptr, ddc
                    , "int", dx
                    , "int", dy
                    , "int", dw
                    , "int", dh
                    , Ptr, sdc
                    , "int", sx
                    , "int", sy
                    , "int", sw
                    , "int", sh
                    , "uint", Raster ? Raster : 0x00CC0020)
}


SetStretchBltMode(hdc, iStretchMode=4)
{
    return DllCall("gdi32\SetStretchBltMode"
                    , A_PtrSize ? "UPtr" : "UInt", hdc
                    , "int", iStretchMode)
}


SetImage(hwnd, hBitmap)
{
    SendMessage, 0x172, 0x0, hBitmap,, ahk_id %hwnd%
    E := ErrorLevel
    DeleteObject(E)
    return E
}


SetSysColorToControl(hwnd, SysColor=15)
{
   WinGetPos,,, w, h, ahk_id %hwnd%
   bc := DllCall("GetSysColor", "Int", SysColor, "UInt")
   pBrushClear := Gdip_BrushCreateSolid(0xff000000 | (bc >> 16 | bc & 0xff00 | (bc & 0xff) << 16))
   pBitmap := Gdip_CreateBitmap(w, h), G := Gdip_GraphicsFromImage(pBitmap)
   Gdip_FillRectangle(G, pBrushClear, 0, 0, w, h)
   hBitmap := Gdip_CreateHBITMAPFromBitmap(pBitmap)
   SetImage(hwnd, hBitmap)
   Gdip_DeleteBrush(pBrushClear)
   Gdip_DeleteGraphics(G), Gdip_DisposeImage(pBitmap), DeleteObject(hBitmap)
   return 0
}


Gdip_BitmapFromScreen(Screen=0, Raster="")
{
    if (Screen = 0)
    {
        Sysget, x, 76
        Sysget, y, 77
        Sysget, w, 78
        Sysget, h, 79
    }
    else if (SubStr(Screen, 1, 5) = "hwnd:")
    {
        Screen := SubStr(Screen, 6)
        if !WinExist( "ahk_id " Screen)
            return -2
        WinGetPos,,, w, h, ahk_id %Screen%
        x := y := 0
        hhdc := GetDCEx(Screen, 3)
    }
    else if (Screen&1 != "")
    {
        Sysget, M, Monitor, %Screen%
        x := MLeft, y := MTop, w := MRight-MLeft, h := MBottom-MTop
    }
    else
    {
        StringSplit, S, Screen, |
        x := S1, y := S2, w := S3, h := S4
    }

    if (x = "") || (y = "") || (w = "") || (h = "")
        return -1

    chdc := CreateCompatibleDC(), hbm := CreateDIBSection(w, h, chdc), obm := SelectObject(chdc, hbm), hhdc := hhdc ? hhdc : GetDC()
    BitBlt(chdc, 0, 0, w, h, hhdc, x, y, Raster)
    ReleaseDC(hhdc)

    pBitmap := Gdip_CreateBitmapFromHBITMAP(hbm)
    SelectObject(chdc, obm), DeleteObject(hbm), DeleteDC(hhdc), DeleteDC(chdc)
    return pBitmap
}



Gdip_BitmapFromHWND(hwnd)
{
    WinGetPos,,, Width, Height, ahk_id %hwnd%
    hbm := CreateDIBSection(Width, Height), hdc := CreateCompatibleDC(), obm := SelectObject(hdc, hbm)
    PrintWindow(hwnd, hdc)
    pBitmap := Gdip_CreateBitmapFromHBITMAP(hbm)
    SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc)
    return pBitmap
}



CreateRectF(ByRef RectF, x, y, w, h)
{
   VarSetCapacity(RectF, 16)
   NumPut(x, RectF, 0, "float"), NumPut(y, RectF, 4, "float"), NumPut(w, RectF, 8, "float"), NumPut(h, RectF, 12, "float")
}



CreateRect(ByRef Rect, x, y, w, h)
{
    VarSetCapacity(Rect, 16)
    NumPut(x, Rect, 0, "uint"), NumPut(y, Rect, 4, "uint"), NumPut(w, Rect, 8, "uint"), NumPut(h, Rect, 12, "uint")
}


CreateSizeF(ByRef SizeF, w, h)
{
   VarSetCapacity(SizeF, 8)
   NumPut(w, SizeF, 0, "float"), NumPut(h, SizeF, 4, "float")
}


CreatePointF(ByRef PointF, x, y)
{
   VarSetCapacity(PointF, 8)
   NumPut(x, PointF, 0, "float"), NumPut(y, PointF, 4, "float")
}

CreateDIBSection(w, h, hdc="", bpp=32, ByRef ppvBits=0)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    hdc2 := hdc ? hdc : GetDC()
    VarSetCapacity(bi, 40, 0)

    NumPut(w, bi, 4, "uint")
    , NumPut(h, bi, 8, "uint")
    , NumPut(40, bi, 0, "uint")
    , NumPut(1, bi, 12, "ushort")
    , NumPut(0, bi, 16, "uInt")
    , NumPut(bpp, bi, 14, "ushort")

    hbm := DllCall("CreateDIBSection"
                    , Ptr, hdc2
                    , Ptr, &bi
                    , "uint", 0
                    , A_PtrSize ? "UPtr*" : "uint*", ppvBits
                    , Ptr, 0
                    , "uint", 0, Ptr)

    if !hdc
        ReleaseDC(hdc2)
    return hbm
}


PrintWindow(hwnd, hdc, Flags=0)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("PrintWindow", Ptr, hwnd, Ptr, hdc, "uint", Flags)
}

DestroyIcon(hIcon)
{
    return DllCall("DestroyIcon", A_PtrSize ? "UPtr" : "UInt", hIcon)
}

;#####################################################################################

PaintDesktop(hdc)
{
    return DllCall("PaintDesktop", A_PtrSize ? "UPtr" : "UInt", hdc)
}

;#####################################################################################

CreateCompatibleBitmap(hdc, w, h)
{
    return DllCall("gdi32\CreateCompatibleBitmap", A_PtrSize ? "UPtr" : "UInt", hdc, "int", w, "int", h)
}


CreateCompatibleDC(hdc=0)
{
   return DllCall("CreateCompatibleDC", A_PtrSize ? "UPtr" : "UInt", hdc)
}


SelectObject(hdc, hgdiobj)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("SelectObject", Ptr, hdc, Ptr, hgdiobj)
}

DeleteObject(hObject)
{
   return DllCall("DeleteObject", A_PtrSize ? "UPtr" : "UInt", hObject)
}


GetDC(hwnd=0)
{
    return DllCall("GetDC", A_PtrSize ? "UPtr" : "UInt", hwnd)
}

GetDCEx(hwnd, flags=0, hrgnClip=0)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("GetDCEx", Ptr, hwnd, Ptr, hrgnClip, "int", flags)
}

ReleaseDC(hdc, hwnd=0)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("ReleaseDC", Ptr, hwnd, Ptr, hdc)
}

DeleteDC(hdc)
{
   return DllCall("DeleteDC", A_PtrSize ? "UPtr" : "UInt", hdc)
}

Gdip_LibraryVersion()
{
    return 1.45
}


Gdip_LibrarySubVersion()
{
    return 1.47
}


Gdip_BitmapFromBRA(ByRef BRAFromMemIn, File, Alternate=0)
{
    Static FName = "ObjRelease"

    if !BRAFromMemIn
        return -1
    Loop, Parse, BRAFromMemIn, `n
    {
        if (A_Index = 1)
        {
            StringSplit, Header, A_LoopField, |
            if (Header0 != 4 || Header2 != "BRA!")
                return -2
        }
        else if (A_Index = 2)
        {
            StringSplit, Info, A_LoopField, |
            if (Info0 != 3)
                return -3
        }
        else
            break
    }
    if !Alternate
        StringReplace, File, File, \, \\, All
    RegExMatch(BRAFromMemIn, "mi`n)^" (Alternate ? File "\|.+?\|(\d+)\|(\d+)" : "\d+\|" File "\|(\d+)\|(\d+)") "$", FileInfo)
    if !FileInfo
        return -4

    hData := DllCall("GlobalAlloc", "uint", 2, Ptr, FileInfo2, Ptr)
    pData := DllCall("GlobalLock", Ptr, hData, Ptr)
    DllCall("RtlMoveMemory", Ptr, pData, Ptr, &BRAFromMemIn+Info2+FileInfo1, Ptr, FileInfo2)
    DllCall("GlobalUnlock", Ptr, hData)
    DllCall("ole32\CreateStreamOnHGlobal", Ptr, hData, "int", 1, A_PtrSize ? "UPtr*" : "UInt*", pStream)
    DllCall("gdiplus\GdipCreateBitmapFromStream", Ptr, pStream, A_PtrSize ? "UPtr*" : "UInt*", pBitmap)
    If (A_PtrSize)
        %FName%(pStream)
    Else
        DllCall(NumGet(NumGet(1*pStream)+8), "uint", pStream)
    return pBitmap
}


Gdip_DrawRectangle(pGraphics, pPen, x, y, w, h)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipDrawRectangle", Ptr, pGraphics, Ptr, pPen, "float", x, "float", y, "float", w, "float", h)
}

Gdip_DrawRoundedRectangle(pGraphics, pPen, x, y, w, h, r)
{
    Gdip_SetClipRect(pGraphics, x-r, y-r, 2*r, 2*r, 4)
    Gdip_SetClipRect(pGraphics, x+w-r, y-r, 2*r, 2*r, 4)
    Gdip_SetClipRect(pGraphics, x-r, y+h-r, 2*r, 2*r, 4)
    Gdip_SetClipRect(pGraphics, x+w-r, y+h-r, 2*r, 2*r, 4)
    E := Gdip_DrawRectangle(pGraphics, pPen, x, y, w, h)
    Gdip_ResetClip(pGraphics)
    Gdip_SetClipRect(pGraphics, x-(2*r), y+r, w+(4*r), h-(2*r), 4)
    Gdip_SetClipRect(pGraphics, x+r, y-(2*r), w-(2*r), h+(4*r), 4)
    Gdip_DrawEllipse(pGraphics, pPen, x, y, 2*r, 2*r)
    Gdip_DrawEllipse(pGraphics, pPen, x+w-(2*r), y, 2*r, 2*r)
    Gdip_DrawEllipse(pGraphics, pPen, x, y+h-(2*r), 2*r, 2*r)
    Gdip_DrawEllipse(pGraphics, pPen, x+w-(2*r), y+h-(2*r), 2*r, 2*r)
    Gdip_ResetClip(pGraphics)
    return E
}


Gdip_DrawEllipse(pGraphics, pPen, x, y, w, h)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipDrawEllipse", Ptr, pGraphics, Ptr, pPen, "float", x, "float", y, "float", w, "float", h)
}

;
Gdip_DrawBezier(pGraphics, pPen, x1, y1, x2, y2, x3, y3, x4, y4)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipDrawBezier"
                    , Ptr, pgraphics
                    , Ptr, pPen
                    , "float", x1
                    , "float", y1
                    , "float", x2
                    , "float", y2
                    , "float", x3
                    , "float", y3
                    , "float", x4
                    , "float", y4)
}

Gdip_DrawArc(pGraphics, pPen, x, y, w, h, StartAngle, SweepAngle)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipDrawArc"
                    , Ptr, pGraphics
                    , Ptr, pPen
                    , "float", x
                    , "float", y
                    , "float", w
                    , "float", h
                    , "float", StartAngle
                    , "float", SweepAngle)
}

Gdip_DrawPie(pGraphics, pPen, x, y, w, h, StartAngle, SweepAngle)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipDrawPie", Ptr, pGraphics, Ptr, pPen, "float", x, "float", y, "float", w, "float", h, "float", StartAngle, "float", SweepAngle)
}


Gdip_DrawLine(pGraphics, pPen, x1, y1, x2, y2)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipDrawLine"
                    , Ptr, pGraphics
                    , Ptr, pPen
                    , "float", x1
                    , "float", y1
                    , "float", x2
                    , "float", y2)
}

Gdip_DrawLines(pGraphics, pPen, Points)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"
    StringSplit, Points, Points, |
    VarSetCapacity(PointF, 8*Points0)
    Loop, %Points0%
    {
        StringSplit, Coord, Points%A_Index%, `,
        NumPut(Coord1, PointF, 8*(A_Index-1), "float"), NumPut(Coord2, PointF, (8*(A_Index-1))+4, "float")
    }
    return DllCall("gdiplus\GdipDrawLines", Ptr, pGraphics, Ptr, pPen, Ptr, &PointF, "int", Points0)
}

Gdip_FillRectangle(pGraphics, pBrush, x, y, w, h)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipFillRectangle"
                    , Ptr, pGraphics
                    , Ptr, pBrush
                    , "float", x
                    , "float", y
                    , "float", w
                    , "float", h)
}

Gdip_FillRoundedRectangle(pGraphics, pBrush, x, y, w, h, r)
{
    Region := Gdip_GetClipRegion(pGraphics)
    Gdip_SetClipRect(pGraphics, x-r, y-r, 2*r, 2*r, 4)
    Gdip_SetClipRect(pGraphics, x+w-r, y-r, 2*r, 2*r, 4)
    Gdip_SetClipRect(pGraphics, x-r, y+h-r, 2*r, 2*r, 4)
    Gdip_SetClipRect(pGraphics, x+w-r, y+h-r, 2*r, 2*r, 4)
    E := Gdip_FillRectangle(pGraphics, pBrush, x, y, w, h)
    Gdip_SetClipRegion(pGraphics, Region, 0)
    Gdip_SetClipRect(pGraphics, x-(2*r), y+r, w+(4*r), h-(2*r), 4)
    Gdip_SetClipRect(pGraphics, x+r, y-(2*r), w-(2*r), h+(4*r), 4)
    Gdip_FillEllipse(pGraphics, pBrush, x, y, 2*r, 2*r)
    Gdip_FillEllipse(pGraphics, pBrush, x+w-(2*r), y, 2*r, 2*r)
    Gdip_FillEllipse(pGraphics, pBrush, x, y+h-(2*r), 2*r, 2*r)
    Gdip_FillEllipse(pGraphics, pBrush, x+w-(2*r), y+h-(2*r), 2*r, 2*r)
    Gdip_SetClipRegion(pGraphics, Region, 0)
    Gdip_DeleteRegion(Region)
    return E
}

Gdip_FillPolygon(pGraphics, pBrush, Points, FillMode=0)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    StringSplit, Points, Points, |
    VarSetCapacity(PointF, 8*Points0)
    Loop, %Points0%
    {
        StringSplit, Coord, Points%A_Index%, `,
        NumPut(Coord1, PointF, 8*(A_Index-1), "float"), NumPut(Coord2, PointF, (8*(A_Index-1))+4, "float")
    }
    return DllCall("gdiplus\GdipFillPolygon", Ptr, pGraphics, Ptr, pBrush, Ptr, &PointF, "int", Points0, "int", FillMode)
}

Gdip_FillPie(pGraphics, pBrush, x, y, w, h, StartAngle, SweepAngle)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipFillPie"
                    , Ptr, pGraphics
                    , Ptr, pBrush
                    , "float", x
                    , "float", y
                    , "float", w
                    , "float", h
                    , "float", StartAngle
                    , "float", SweepAngle)
}

Gdip_FillEllipse(pGraphics, pBrush, x, y, w, h)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipFillEllipse", Ptr, pGraphics, Ptr, pBrush, "float", x, "float", y, "float", w, "float", h)
}

Gdip_FillRegion(pGraphics, pBrush, Region)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipFillRegion", Ptr, pGraphics, Ptr, pBrush, Ptr, Region)
}

Gdip_FillPath(pGraphics, pBrush, Path)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipFillPath", Ptr, pGraphics, Ptr, pBrush, Ptr, Path)
}

Gdip_DrawImagePointsRect(pGraphics, pBitmap, Points, sx="", sy="", sw="", sh="", Matrix=1)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    StringSplit, Points, Points, |
    VarSetCapacity(PointF, 8*Points0)
    Loop, %Points0%
    {
        StringSplit, Coord, Points%A_Index%, `,
        NumPut(Coord1, PointF, 8*(A_Index-1), "float"), NumPut(Coord2, PointF, (8*(A_Index-1))+4, "float")
    }

    if (Matrix&1 = "")
        ImageAttr := Gdip_SetImageAttributesColorMatrix(Matrix)
    else if (Matrix != 1)
        ImageAttr := Gdip_SetImageAttributesColorMatrix("1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|" Matrix "|0|0|0|0|0|1")

    if (sx = "" && sy = "" && sw = "" && sh = "")
    {
        sx := 0, sy := 0
        sw := Gdip_GetImageWidth(pBitmap)
        sh := Gdip_GetImageHeight(pBitmap)
    }

    E := DllCall("gdiplus\GdipDrawImagePointsRect"
                , Ptr, pGraphics
                , Ptr, pBitmap
                , Ptr, &PointF
                , "int", Points0
                , "float", sx
                , "float", sy
                , "float", sw
                , "float", sh
                , "int", 2
                , Ptr, ImageAttr
                , Ptr, 0
                , Ptr, 0)
    if ImageAttr
        Gdip_DisposeImageAttributes(ImageAttr)
    return E
}


Gdip_DrawImage(pGraphics, pBitmap, dx="", dy="", dw="", dh="", sx="", sy="", sw="", sh="", Matrix=1)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    if (Matrix&1 = "")
        ImageAttr := Gdip_SetImageAttributesColorMatrix(Matrix)
    else if (Matrix != 1)
        ImageAttr := Gdip_SetImageAttributesColorMatrix("1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|" Matrix "|0|0|0|0|0|1")

    if (sx = "" && sy = "" && sw = "" && sh = "")
    {
        if (dx = "" && dy = "" && dw = "" && dh = "")
        {
            sx := dx := 0, sy := dy := 0
            sw := dw := Gdip_GetImageWidth(pBitmap)
            sh := dh := Gdip_GetImageHeight(pBitmap)
        }
        else
        {
            sx := sy := 0
            sw := Gdip_GetImageWidth(pBitmap)
            sh := Gdip_GetImageHeight(pBitmap)
        }
    }

    E := DllCall("gdiplus\GdipDrawImageRectRect"
                , Ptr, pGraphics
                , Ptr, pBitmap
                , "float", dx
                , "float", dy
                , "float", dw
                , "float", dh
                , "float", sx
                , "float", sy
                , "float", sw
                , "float", sh
                , "int", 2
                , Ptr, ImageAttr
                , Ptr, 0
                , Ptr, 0)
    if ImageAttr
        Gdip_DisposeImageAttributes(ImageAttr)
    return E
}

Gdip_SetImageAttributesColorMatrix(Matrix)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    VarSetCapacity(ColourMatrix, 100, 0)
    Matrix := RegExReplace(RegExReplace(Matrix, "^[^\d-\.]+([\d\.])", "$1", "", 1), "[^\d-\.]+", "|")
    StringSplit, Matrix, Matrix, |
    Loop, 25
    {
        Matrix := (Matrix%A_Index% != "") ? Matrix%A_Index% : Mod(A_Index-1, 6) ? 0 : 1
        NumPut(Matrix, ColourMatrix, (A_Index-1)*4, "float")
    }
    DllCall("gdiplus\GdipCreateImageAttributes", A_PtrSize ? "UPtr*" : "uint*", ImageAttr)
    DllCall("gdiplus\GdipSetImageAttributesColorMatrix", Ptr, ImageAttr, "int", 1, "int", 1, Ptr, &ColourMatrix, Ptr, 0, "int", 0)
    return ImageAttr
}

Gdip_GraphicsFromImage(pBitmap)
{
    DllCall("gdiplus\GdipGetImageGraphicsContext", A_PtrSize ? "UPtr" : "UInt", pBitmap, A_PtrSize ? "UPtr*" : "UInt*", pGraphics)
    return pGraphics
}


Gdip_GraphicsFromHDC(hdc)
{
    DllCall("gdiplus\GdipCreateFromHDC", A_PtrSize ? "UPtr" : "UInt", hdc, A_PtrSize ? "UPtr*" : "UInt*", pGraphics)
    return pGraphics
}

Gdip_GetDC(pGraphics)
{
    DllCall("gdiplus\GdipGetDC", A_PtrSize ? "UPtr" : "UInt", pGraphics, A_PtrSize ? "UPtr*" : "UInt*", hdc)
    return hdc
}

Gdip_ReleaseDC(pGraphics, hdc)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipReleaseDC", Ptr, pGraphics, Ptr, hdc)
}

Gdip_GraphicsClear(pGraphics, ARGB=0x00ffffff)
{
    return DllCall("gdiplus\GdipGraphicsClear", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", ARGB)
}

Gdip_BlurBitmap(pBitmap, Blur)
{
    if (Blur > 100) || (Blur < 1)
        return -1

    sWidth := Gdip_GetImageWidth(pBitmap), sHeight := Gdip_GetImageHeight(pBitmap)
    dWidth := sWidth//Blur, dHeight := sHeight//Blur

    pBitmap1 := Gdip_CreateBitmap(dWidth, dHeight)
    G1 := Gdip_GraphicsFromImage(pBitmap1)
    Gdip_SetInterpolationMode(G1, 7)
    Gdip_DrawImage(G1, pBitmap, 0, 0, dWidth, dHeight, 0, 0, sWidth, sHeight)

    Gdip_DeleteGraphics(G1)

    pBitmap2 := Gdip_CreateBitmap(sWidth, sHeight)
    G2 := Gdip_GraphicsFromImage(pBitmap2)
    Gdip_SetInterpolationMode(G2, 7)
    Gdip_DrawImage(G2, pBitmap1, 0, 0, sWidth, sHeight, 0, 0, dWidth, dHeight)

    Gdip_DeleteGraphics(G2)
    Gdip_DisposeImage(pBitmap1)
    return pBitmap2
}

Gdip_SaveBitmapToFile(pBitmap, sOutput, Quality=75)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    SplitPath, sOutput,,, Extension
    if Extension not in BMP,DIB,RLE,JPG,JPEG,JPE,JFIF,GIF,TIF,TIFF,PNG
        return -1
    Extension := "." Extension

    DllCall("gdiplus\GdipGetImageEncodersSize", "uint*", nCount, "uint*", nSize)
    VarSetCapacity(ci, nSize)
    DllCall("gdiplus\GdipGetImageEncoders", "uint", nCount, "uint", nSize, Ptr, &ci)
    if !(nCount && nSize)
        return -2

    If (A_IsUnicode){
        StrGet_Name := "StrGet"
        Loop, %nCount%
        {
            sString := %StrGet_Name%(NumGet(ci, (idx := (48+7*A_PtrSize)*(A_Index-1))+32+3*A_PtrSize), "UTF-16")
            if !InStr(sString, "*" Extension)
                continue

            pCodec := &ci+idx
            break
        }
    } else {
        Loop, %nCount%
        {
            Location := NumGet(ci, 76*(A_Index-1)+44)
            nSize := DllCall("WideCharToMultiByte", "uint", 0, "uint", 0, "uint", Location, "int", -1, "uint", 0, "int",  0, "uint", 0, "uint", 0)
            VarSetCapacity(sString, nSize)
            DllCall("WideCharToMultiByte", "uint", 0, "uint", 0, "uint", Location, "int", -1, "str", sString, "int", nSize, "uint", 0, "uint", 0)
            if !InStr(sString, "*" Extension)
                continue

            pCodec := &ci+76*(A_Index-1)
            break
        }
    }

    if !pCodec
        return -3

    if (Quality != 75)
    {
        Quality := (Quality < 0) ? 0 : (Quality > 100) ? 100 : Quality
        if Extension in .JPG,.JPEG,.JPE,.JFIF
        {
            DllCall("gdiplus\GdipGetEncoderParameterListSize", Ptr, pBitmap, Ptr, pCodec, "uint*", nSize)
            VarSetCapacity(EncoderParameters, nSize, 0)
            DllCall("gdiplus\GdipGetEncoderParameterList", Ptr, pBitmap, Ptr, pCodec, "uint", nSize, Ptr, &EncoderParameters)
            Loop, % NumGet(EncoderParameters, "UInt")      ;%
            {
                elem := (24+(A_PtrSize ? A_PtrSize : 4))*(A_Index-1) + 4 + (pad := A_PtrSize = 8 ? 4 : 0)
                if (NumGet(EncoderParameters, elem+16, "UInt") = 1) && (NumGet(EncoderParameters, elem+20, "UInt") = 6)
                {
                    p := elem+&EncoderParameters-pad-4
                    NumPut(Quality, NumGet(NumPut(4, NumPut(1, p+0)+20, "UInt")), "UInt")
                    break
                }
            }
        }
    }

    if (!A_IsUnicode)
    {
        nSize := DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sOutput, "int", -1, Ptr, 0, "int", 0)
        VarSetCapacity(wOutput, nSize*2)
        DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sOutput, "int", -1, Ptr, &wOutput, "int", nSize)
        VarSetCapacity(wOutput, -1)
        if !VarSetCapacity(wOutput)
            return -4
        E := DllCall("gdiplus\GdipSaveImageToFile", Ptr, pBitmap, Ptr, &wOutput, Ptr, pCodec, "uint", p ? p : 0)
    }
    else
        E := DllCall("gdiplus\GdipSaveImageToFile", Ptr, pBitmap, Ptr, &sOutput, Ptr, pCodec, "uint", p ? p : 0)
    return E ? -5 : 0
}

Gdip_GetPixel(pBitmap, x, y)
{
    DllCall("gdiplus\GdipBitmapGetPixel", A_PtrSize ? "UPtr" : "UInt", pBitmap, "int", x, "int", y, "uint*", ARGB)
    return ARGB
}



Gdip_SetPixel(pBitmap, x, y, ARGB)
{
   return DllCall("gdiplus\GdipBitmapSetPixel", A_PtrSize ? "UPtr" : "UInt", pBitmap, "int", x, "int", y, "int", ARGB)
}

Gdip_GetImageWidth(pBitmap)
{
   DllCall("gdiplus\GdipGetImageWidth", A_PtrSize ? "UPtr" : "UInt", pBitmap, "uint*", Width)
   return Width
}


Gdip_GetImageHeight(pBitmap)
{
   DllCall("gdiplus\GdipGetImageHeight", A_PtrSize ? "UPtr" : "UInt", pBitmap, "uint*", Height)
   return Height
}


Gdip_GetImageDimensions(pBitmap, ByRef Width, ByRef Height)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"
    DllCall("gdiplus\GdipGetImageWidth", Ptr, pBitmap, "uint*", Width)
    DllCall("gdiplus\GdipGetImageHeight", Ptr, pBitmap, "uint*", Height)
}

;#####################################################################################

Gdip_GetDimensions(pBitmap, ByRef Width, ByRef Height)
{
    Gdip_GetImageDimensions(pBitmap, Width, Height)
}

;#####################################################################################

Gdip_GetImagePixelFormat(pBitmap)
{
    DllCall("gdiplus\GdipGetImagePixelFormat", A_PtrSize ? "UPtr" : "UInt", pBitmap, A_PtrSize ? "UPtr*" : "UInt*", Format)
    return Format
}


Gdip_GetDpiX(pGraphics)
{
    DllCall("gdiplus\GdipGetDpiX", A_PtrSize ? "UPtr" : "uint", pGraphics, "float*", dpix)
    return Round(dpix)
}

;#####################################################################################

Gdip_GetDpiY(pGraphics)
{
    DllCall("gdiplus\GdipGetDpiY", A_PtrSize ? "UPtr" : "uint", pGraphics, "float*", dpiy)
    return Round(dpiy)
}

;#####################################################################################

Gdip_GetImageHorizontalResolution(pBitmap)
{
    DllCall("gdiplus\GdipGetImageHorizontalResolution", A_PtrSize ? "UPtr" : "uint", pBitmap, "float*", dpix)
    return Round(dpix)
}

;#####################################################################################

Gdip_GetImageVerticalResolution(pBitmap)
{
    DllCall("gdiplus\GdipGetImageVerticalResolution", A_PtrSize ? "UPtr" : "uint", pBitmap, "float*", dpiy)
    return Round(dpiy)
}

;#####################################################################################

Gdip_BitmapSetResolution(pBitmap, dpix, dpiy)
{
    return DllCall("gdiplus\GdipBitmapSetResolution", A_PtrSize ? "UPtr" : "uint", pBitmap, "float", dpix, "float", dpiy)
}

;#####################################################################################

Gdip_CreateBitmapFromFile(sFile, IconNumber=1, IconSize="")
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"
    , PtrA := A_PtrSize ? "UPtr*" : "UInt*"

    SplitPath, sFile,,, ext
    if ext in exe,dll
    {
        Sizes := IconSize ? IconSize : 256 "|" 128 "|" 64 "|" 48 "|" 32 "|" 16
        BufSize := 16 + (2*(A_PtrSize ? A_PtrSize : 4))

        VarSetCapacity(buf, BufSize, 0)
        Loop, Parse, Sizes, |
        {
            DllCall("PrivateExtractIcons", "str", sFile, "int", IconNumber-1, "int", A_LoopField, "int", A_LoopField, PtrA, hIcon, PtrA, 0, "uint", 1, "uint", 0)

            if !hIcon
                continue

            if !DllCall("GetIconInfo", Ptr, hIcon, Ptr, &buf)
            {
                DestroyIcon(hIcon)
                continue
            }

            hbmMask  := NumGet(buf, 12 + ((A_PtrSize ? A_PtrSize : 4) - 4))
            hbmColor := NumGet(buf, 12 + ((A_PtrSize ? A_PtrSize : 4) - 4) + (A_PtrSize ? A_PtrSize : 4))
            if !(hbmColor && DllCall("GetObject", Ptr, hbmColor, "int", BufSize, Ptr, &buf))
            {
                DestroyIcon(hIcon)
                continue
            }
            break
        }
        if !hIcon
            return -1

        Width := NumGet(buf, 4, "int"), Height := NumGet(buf, 8, "int")
        hbm := CreateDIBSection(Width, -Height), hdc := CreateCompatibleDC(), obm := SelectObject(hdc, hbm)
        if !DllCall("DrawIconEx", Ptr, hdc, "int", 0, "int", 0, Ptr, hIcon, "uint", Width, "uint", Height, "uint", 0, Ptr, 0, "uint", 3)
        {
            DestroyIcon(hIcon)
            return -2
        }

        VarSetCapacity(dib, 104)
        DllCall("GetObject", Ptr, hbm, "int", A_PtrSize = 8 ? 104 : 84, Ptr, &dib) ; sizeof(DIBSECTION) = 76+2*(A_PtrSize=8?4:0)+2*A_PtrSize
        Stride := NumGet(dib, 12, "Int"), Bits := NumGet(dib, 20 + (A_PtrSize = 8 ? 4 : 0)) ; padding
        DllCall("gdiplus\GdipCreateBitmapFromScan0", "int", Width, "int", Height, "int", Stride, "int", 0x26200A, Ptr, Bits, PtrA, pBitmapOld)
        pBitmap := Gdip_CreateBitmap(Width, Height)
        G := Gdip_GraphicsFromImage(pBitmap)
        , Gdip_DrawImage(G, pBitmapOld, 0, 0, Width, Height, 0, 0, Width, Height)
        SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc)
        Gdip_DeleteGraphics(G), Gdip_DisposeImage(pBitmapOld)
        DestroyIcon(hIcon)
    }
    else
    {
        if (!A_IsUnicode)
        {
            VarSetCapacity(wFile, 1024)
            DllCall("kernel32\MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sFile, "int", -1, Ptr, &wFile, "int", 512)
            DllCall("gdiplus\GdipCreateBitmapFromFile", Ptr, &wFile, PtrA, pBitmap)
        }
        else
            DllCall("gdiplus\GdipCreateBitmapFromFile", Ptr, &sFile, PtrA, pBitmap)
    }

    return pBitmap
}

;#####################################################################################

Gdip_CreateBitmapFromHBITMAP(hBitmap, Palette=0)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    DllCall("gdiplus\GdipCreateBitmapFromHBITMAP", Ptr, hBitmap, Ptr, Palette, A_PtrSize ? "UPtr*" : "uint*", pBitmap)
    return pBitmap
}

;#####################################################################################

Gdip_CreateHBITMAPFromBitmap(pBitmap, Background=0xffffffff)
{
    DllCall("gdiplus\GdipCreateHBITMAPFromBitmap", A_PtrSize ? "UPtr" : "UInt", pBitmap, A_PtrSize ? "UPtr*" : "uint*", hbm, "int", Background)
    return hbm
}

;#####################################################################################

Gdip_CreateBitmapFromHICON(hIcon)
{
    DllCall("gdiplus\GdipCreateBitmapFromHICON", A_PtrSize ? "UPtr" : "UInt", hIcon, A_PtrSize ? "UPtr*" : "uint*", pBitmap)
    return pBitmap
}

;#####################################################################################

Gdip_CreateHICONFromBitmap(pBitmap)
{
    DllCall("gdiplus\GdipCreateHICONFromBitmap", A_PtrSize ? "UPtr" : "UInt", pBitmap, A_PtrSize ? "UPtr*" : "uint*", hIcon)
    return hIcon
}

;#####################################################################################

Gdip_CreateBitmap(Width, Height, Format=0x26200A)
{
    DllCall("gdiplus\GdipCreateBitmapFromScan0", "int", Width, "int", Height, "int", 0, "int", Format, A_PtrSize ? "UPtr" : "UInt", 0, A_PtrSize ? "UPtr*" : "uint*", pBitmap)
    Return pBitmap
}

;#####################################################################################

Gdip_CreateBitmapFromClipboard()
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    if !DllCall("OpenClipboard", Ptr, 0)
        return -1
    if !DllCall("IsClipboardFormatAvailable", "uint", 8)
        return -2
    if !hBitmap := DllCall("GetClipboardData", "uint", 2, Ptr)
        return -3
    if !pBitmap := Gdip_CreateBitmapFromHBITMAP(hBitmap)
        return -4
    if !DllCall("CloseClipboard")
        return -5
    DeleteObject(hBitmap)
    return pBitmap
}

;#####################################################################################

Gdip_SetBitmapToClipboard(pBitmap)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"
    off1 := A_PtrSize = 8 ? 52 : 44, off2 := A_PtrSize = 8 ? 32 : 24
    hBitmap := Gdip_CreateHBITMAPFromBitmap(pBitmap)
    DllCall("GetObject", Ptr, hBitmap, "int", VarSetCapacity(oi, A_PtrSize = 8 ? 104 : 84, 0), Ptr, &oi)
    hdib := DllCall("GlobalAlloc", "uint", 2, Ptr, 40+NumGet(oi, off1, "UInt"), Ptr)
    pdib := DllCall("GlobalLock", Ptr, hdib, Ptr)
    DllCall("RtlMoveMemory", Ptr, pdib, Ptr, &oi+off2, Ptr, 40)
    DllCall("RtlMoveMemory", Ptr, pdib+40, Ptr, NumGet(oi, off2 - (A_PtrSize ? A_PtrSize : 4), Ptr), Ptr, NumGet(oi, off1, "UInt"))
    DllCall("GlobalUnlock", Ptr, hdib)
    DllCall("DeleteObject", Ptr, hBitmap)
    DllCall("OpenClipboard", Ptr, 0)
    DllCall("EmptyClipboard")
    DllCall("SetClipboardData", "uint", 8, Ptr, hdib)
    DllCall("CloseClipboard")
}

;#####################################################################################

Gdip_CloneBitmapArea(pBitmap, x, y, w, h, Format=0x26200A)
{
    DllCall("gdiplus\GdipCloneBitmapArea"
                    , "float", x
                    , "float", y
                    , "float", w
                    , "float", h
                    , "int", Format
                    , A_PtrSize ? "UPtr" : "UInt", pBitmap
                    , A_PtrSize ? "UPtr*" : "UInt*", pBitmapDest)
    return pBitmapDest
}

;#####################################################################################
; Create resources
;#####################################################################################

Gdip_CreatePen(ARGB, w)
{
   DllCall("gdiplus\GdipCreatePen1", "UInt", ARGB, "float", w, "int", 2, A_PtrSize ? "UPtr*" : "UInt*", pPen)
   return pPen
}

;#####################################################################################

Gdip_CreatePenFromBrush(pBrush, w)
{
    DllCall("gdiplus\GdipCreatePen2", A_PtrSize ? "UPtr" : "UInt", pBrush, "float", w, "int", 2, A_PtrSize ? "UPtr*" : "UInt*", pPen)
    return pPen
}

;#####################################################################################

Gdip_BrushCreateSolid(ARGB=0xff000000)
{
    DllCall("gdiplus\GdipCreateSolidFill", "UInt", ARGB, A_PtrSize ? "UPtr*" : "UInt*", pBrush)
    return pBrush
}

Gdip_BrushCreateHatch(ARGBfront, ARGBback, HatchStyle=0)
{
    DllCall("gdiplus\GdipCreateHatchBrush", "int", HatchStyle, "UInt", ARGBfront, "UInt", ARGBback, A_PtrSize ? "UPtr*" : "UInt*", pBrush)
    return pBrush
}

;#####################################################################################

Gdip_CreateTextureBrush(pBitmap, WrapMode=1, x=0, y=0, w="", h="")
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"
    , PtrA := A_PtrSize ? "UPtr*" : "UInt*"

    if !(w && h)
        DllCall("gdiplus\GdipCreateTexture", Ptr, pBitmap, "int", WrapMode, PtrA, pBrush)
    else
        DllCall("gdiplus\GdipCreateTexture2", Ptr, pBitmap, "int", WrapMode, "float", x, "float", y, "float", w, "float", h, PtrA, pBrush)
    return pBrush
}

;#####################################################################################

Gdip_CreateLineBrush(x1, y1, x2, y2, ARGB1, ARGB2, WrapMode=1)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    CreatePointF(PointF1, x1, y1), CreatePointF(PointF2, x2, y2)
    DllCall("gdiplus\GdipCreateLineBrush", Ptr, &PointF1, Ptr, &PointF2, "Uint", ARGB1, "Uint", ARGB2, "int", WrapMode, A_PtrSize ? "UPtr*" : "UInt*", LGpBrush)
    return LGpBrush
}

;#####################################################################################


Gdip_CreateLineBrushFromRect(x, y, w, h, ARGB1, ARGB2, LinearGradientMode=1, WrapMode=1)
{
    CreateRectF(RectF, x, y, w, h)
    DllCall("gdiplus\GdipCreateLineBrushFromRect", A_PtrSize ? "UPtr" : "UInt", &RectF, "int", ARGB1, "int", ARGB2, "int", LinearGradientMode, "int", WrapMode, A_PtrSize ? "UPtr*" : "UInt*", LGpBrush)
    return LGpBrush
}

;#####################################################################################

Gdip_CloneBrush(pBrush)
{
    DllCall("gdiplus\GdipCloneBrush", A_PtrSize ? "UPtr" : "UInt", pBrush, A_PtrSize ? "UPtr*" : "UInt*", pBrushClone)
    return pBrushClone
}

;#####################################################################################
; Delete resources
;#####################################################################################

Gdip_DeletePen(pPen)
{
   return DllCall("gdiplus\GdipDeletePen", A_PtrSize ? "UPtr" : "UInt", pPen)
}

;#####################################################################################

Gdip_DeleteBrush(pBrush)
{
   return DllCall("gdiplus\GdipDeleteBrush", A_PtrSize ? "UPtr" : "UInt", pBrush)
}

;#####################################################################################

Gdip_DisposeImage(pBitmap)
{
   return DllCall("gdiplus\GdipDisposeImage", A_PtrSize ? "UPtr" : "UInt", pBitmap)
}

;#####################################################################################

Gdip_DeleteGraphics(pGraphics)
{
   return DllCall("gdiplus\GdipDeleteGraphics", A_PtrSize ? "UPtr" : "UInt", pGraphics)
}

;#####################################################################################

Gdip_DisposeImageAttributes(ImageAttr)
{
    return DllCall("gdiplus\GdipDisposeImageAttributes", A_PtrSize ? "UPtr" : "UInt", ImageAttr)
}

;#####################################################################################

Gdip_DeleteFont(hFont)
{
   return DllCall("gdiplus\GdipDeleteFont", A_PtrSize ? "UPtr" : "UInt", hFont)
}

;#####################################################################################

Gdip_DeleteStringFormat(hFormat)
{
   return DllCall("gdiplus\GdipDeleteStringFormat", A_PtrSize ? "UPtr" : "UInt", hFormat)
}

;#####################################################################################

Gdip_DeleteFontFamily(hFamily)
{
   return DllCall("gdiplus\GdipDeleteFontFamily", A_PtrSize ? "UPtr" : "UInt", hFamily)
}

;#####################################################################################

Gdip_DeleteMatrix(Matrix)
{
   return DllCall("gdiplus\GdipDeleteMatrix", A_PtrSize ? "UPtr" : "UInt", Matrix)
}

;#####################################################################################
; Text functions
;#####################################################################################

Gdip_TextToGraphics(pGraphics, Text, Options, Font="Arial", Width="", Height="", Measure=0)
{
    IWidth := Width, IHeight:= Height

    RegExMatch(Options, "i)X([\-\d\.]+)(p*)", xpos)
    RegExMatch(Options, "i)Y([\-\d\.]+)(p*)", ypos)
    RegExMatch(Options, "i)W([\-\d\.]+)(p*)", Width)
    RegExMatch(Options, "i)H([\-\d\.]+)(p*)", Height)
    RegExMatch(Options, "i)C(?!(entre|enter))([a-f\d]+)", Colour)
    RegExMatch(Options, "i)Top|Up|Bottom|Down|vCentre|vCenter", vPos)
    RegExMatch(Options, "i)NoWrap", NoWrap)
    RegExMatch(Options, "i)R(\d)", Rendering)
    RegExMatch(Options, "i)S(\d+)(p*)", Size)

    if !Gdip_DeleteBrush(Gdip_CloneBrush(Colour2))
        PassBrush := 1, pBrush := Colour2

    if !(IWidth && IHeight) && (xpos2 || ypos2 || Width2 || Height2 || Size2)
        return -1

    Style := 0, Styles := "Regular|Bold|Italic|BoldItalic|Underline|Strikeout"
    Loop, Parse, Styles, |
    {
        if RegExMatch(Options, "\b" A_loopField)
        Style |= (A_LoopField != "StrikeOut") ? (A_Index-1) : 8
    }

    Align := 0, Alignments := "Near|Left|Centre|Center|Far|Right"
    Loop, Parse, Alignments, |
    {
        if RegExMatch(Options, "\b" A_loopField)
            Align |= A_Index//2.1      ; 0|0|1|1|2|2
    }

    xpos := (xpos1 != "") ? xpos2 ? IWidth*(xpos1/100) : xpos1 : 0
    ypos := (ypos1 != "") ? ypos2 ? IHeight*(ypos1/100) : ypos1 : 0
    Width := Width1 ? Width2 ? IWidth*(Width1/100) : Width1 : IWidth
    Height := Height1 ? Height2 ? IHeight*(Height1/100) : Height1 : IHeight
    if !PassBrush
        Colour := "0x" (Colour2 ? Colour2 : "ff000000")
    Rendering := ((Rendering1 >= 0) && (Rendering1 <= 5)) ? Rendering1 : 4
    Size := (Size1 > 0) ? Size2 ? IHeight*(Size1/100) : Size1 : 12

    hFamily := Gdip_FontFamilyCreate(Font)
    hFont := Gdip_FontCreate(hFamily, Size, Style)
    FormatStyle := NoWrap ? 0x4000 | 0x1000 : 0x4000
    hFormat := Gdip_StringFormatCreate(FormatStyle)
    pBrush := PassBrush ? pBrush : Gdip_BrushCreateSolid(Colour)
    if !(hFamily && hFont && hFormat && pBrush && pGraphics)
        return !pGraphics ? -2 : !hFamily ? -3 : !hFont ? -4 : !hFormat ? -5 : !pBrush ? -6 : 0

    CreateRectF(RC, xpos, ypos, Width, Height)
    Gdip_SetStringFormatAlign(hFormat, Align)
    Gdip_SetTextRenderingHint(pGraphics, Rendering)
    ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hFormat, RC)

    if vPos
    {
        StringSplit, ReturnRC, ReturnRC, |

        if (vPos = "vCentre") || (vPos = "vCenter")
            ypos += (Height-ReturnRC4)//2
        else if (vPos = "Top") || (vPos = "Up")
            ypos := 0
        else if (vPos = "Bottom") || (vPos = "Down")
            ypos := Height-ReturnRC4

        CreateRectF(RC, xpos, ypos, Width, ReturnRC4)
        ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hFormat, RC)
    }

    if !Measure
        E := Gdip_DrawString(pGraphics, Text, hFont, hFormat, pBrush, RC)

    if !PassBrush
        Gdip_DeleteBrush(pBrush)
    Gdip_DeleteStringFormat(hFormat)
    Gdip_DeleteFont(hFont)
    Gdip_DeleteFontFamily(hFamily)
    return E ? E : ReturnRC
}

;#####################################################################################

Gdip_DrawString(pGraphics, sString, hFont, hFormat, pBrush, ByRef RectF)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    if (!A_IsUnicode)
    {
        nSize := DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sString, "int", -1, Ptr, 0, "int", 0)
        VarSetCapacity(wString, nSize*2)
        DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sString, "int", -1, Ptr, &wString, "int", nSize)
    }

    return DllCall("gdiplus\GdipDrawString"
                    , Ptr, pGraphics
                    , Ptr, A_IsUnicode ? &sString : &wString
                    , "int", -1
                    , Ptr, hFont
                    , Ptr, &RectF
                    , Ptr, hFormat
                    , Ptr, pBrush)
}

;#####################################################################################

Gdip_MeasureString(pGraphics, sString, hFont, hFormat, ByRef RectF)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    VarSetCapacity(RC, 16)
    if !A_IsUnicode
    {
        nSize := DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sString, "int", -1, "uint", 0, "int", 0)
        VarSetCapacity(wString, nSize*2)
        DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sString, "int", -1, Ptr, &wString, "int", nSize)
    }

    DllCall("gdiplus\GdipMeasureString"
                    , Ptr, pGraphics
                    , Ptr, A_IsUnicode ? &sString : &wString
                    , "int", -1
                    , Ptr, hFont
                    , Ptr, &RectF
                    , Ptr, hFormat
                    , Ptr, &RC
                    , "uint*", Chars
                    , "uint*", Lines)

    return &RC ? NumGet(RC, 0, "float") "|" NumGet(RC, 4, "float") "|" NumGet(RC, 8, "float") "|" NumGet(RC, 12, "float") "|" Chars "|" Lines : 0
}

; Near = 0
; Center = 1
; Far = 2
Gdip_SetStringFormatAlign(hFormat, Align)
{
   return DllCall("gdiplus\GdipSetStringFormatAlign", A_PtrSize ? "UPtr" : "UInt", hFormat, "int", Align)
}

Gdip_StringFormatCreate(Format=0, Lang=0)
{
   DllCall("gdiplus\GdipCreateStringFormat", "int", Format, "int", Lang, A_PtrSize ? "UPtr*" : "UInt*", hFormat)
   return hFormat
}

; Regular = 0
; Bold = 1
; Italic = 2
; BoldItalic = 3
; Underline = 4
; Strikeout = 8
Gdip_FontCreate(hFamily, Size, Style=0)
{
   DllCall("gdiplus\GdipCreateFont", A_PtrSize ? "UPtr" : "UInt", hFamily, "float", Size, "int", Style, "int", 0, A_PtrSize ? "UPtr*" : "UInt*", hFont)
   return hFont
}

Gdip_FontFamilyCreate(Font)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    if (!A_IsUnicode)
    {
        nSize := DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &Font, "int", -1, "uint", 0, "int", 0)
        VarSetCapacity(wFont, nSize*2)
        DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &Font, "int", -1, Ptr, &wFont, "int", nSize)
    }

    DllCall("gdiplus\GdipCreateFontFamilyFromName"
                    , Ptr, A_IsUnicode ? &Font : &wFont
                    , "uint", 0
                    , A_PtrSize ? "UPtr*" : "UInt*", hFamily)

    return hFamily
}

;#####################################################################################
; Matrix functions
;#####################################################################################

Gdip_CreateAffineMatrix(m11, m12, m21, m22, x, y)
{
   DllCall("gdiplus\GdipCreateMatrix2", "float", m11, "float", m12, "float", m21, "float", m22, "float", x, "float", y, A_PtrSize ? "UPtr*" : "UInt*", Matrix)
   return Matrix
}

Gdip_CreateMatrix()
{
   DllCall("gdiplus\GdipCreateMatrix", A_PtrSize ? "UPtr*" : "UInt*", Matrix)
   return Matrix
}

;#####################################################################################
; GraphicsPath functions
;#####################################################################################

; Alternate = 0
; Winding = 1
Gdip_CreatePath(BrushMode=0)
{
    DllCall("gdiplus\GdipCreatePath", "int", BrushMode, A_PtrSize ? "UPtr*" : "UInt*", Path)
    return Path
}

Gdip_AddPathEllipse(Path, x, y, w, h)
{
    return DllCall("gdiplus\GdipAddPathEllipse", A_PtrSize ? "UPtr" : "UInt", Path, "float", x, "float", y, "float", w, "float", h)
}

Gdip_AddPathPolygon(Path, Points)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    StringSplit, Points, Points, |
    VarSetCapacity(PointF, 8*Points0)
    Loop, %Points0%
    {
        StringSplit, Coord, Points%A_Index%, `,
        NumPut(Coord1, PointF, 8*(A_Index-1), "float"), NumPut(Coord2, PointF, (8*(A_Index-1))+4, "float")
    }

    return DllCall("gdiplus\GdipAddPathPolygon", Ptr, Path, Ptr, &PointF, "int", Points0)
}

Gdip_DeletePath(Path)
{
    return DllCall("gdiplus\GdipDeletePath", A_PtrSize ? "UPtr" : "UInt", Path)
}

;#####################################################################################
; Quality functions
;#####################################################################################


Gdip_SetTextRenderingHint(pGraphics, RenderingHint)
{
    return DllCall("gdiplus\GdipSetTextRenderingHint", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", RenderingHint)
}


Gdip_SetInterpolationMode(pGraphics, InterpolationMode)
{
   return DllCall("gdiplus\GdipSetInterpolationMode", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", InterpolationMode)
}


Gdip_SetSmoothingMode(pGraphics, SmoothingMode)
{
   return DllCall("gdiplus\GdipSetSmoothingMode", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", SmoothingMode)
}

; CompositingModeSourceOver = 0 (blended)
; CompositingModeSourceCopy = 1 (overwrite)
Gdip_SetCompositingMode(pGraphics, CompositingMode=0)
{
   return DllCall("gdiplus\GdipSetCompositingMode", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", CompositingMode)
}

;#####################################################################################
; Extra functions
;#####################################################################################

Gdip_Startup()
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    if !DllCall("GetModuleHandle", "str", "gdiplus", Ptr)
        DllCall("LoadLibrary", "str", "gdiplus")
    VarSetCapacity(si, A_PtrSize = 8 ? 24 : 16, 0), si := Chr(1)
    DllCall("gdiplus\GdiplusStartup", A_PtrSize ? "UPtr*" : "uint*", pToken, Ptr, &si, Ptr, 0)
    return pToken
}

Gdip_Shutdown(pToken)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    DllCall("gdiplus\GdiplusShutdown", Ptr, pToken)
    if hModule := DllCall("GetModuleHandle", "str", "gdiplus", Ptr)
        DllCall("FreeLibrary", Ptr, hModule)
    return 0
}

; Prepend = 0; The new operation is applied before the old operation.
; Append = 1; The new operation is applied after the old operation.
Gdip_RotateWorldTransform(pGraphics, Angle, MatrixOrder=0)
{
    return DllCall("gdiplus\GdipRotateWorldTransform", A_PtrSize ? "UPtr" : "UInt", pGraphics, "float", Angle, "int", MatrixOrder)
}

Gdip_ScaleWorldTransform(pGraphics, x, y, MatrixOrder=0)
{
    return DllCall("gdiplus\GdipScaleWorldTransform", A_PtrSize ? "UPtr" : "UInt", pGraphics, "float", x, "float", y, "int", MatrixOrder)
}

Gdip_TranslateWorldTransform(pGraphics, x, y, MatrixOrder=0)
{
    return DllCall("gdiplus\GdipTranslateWorldTransform", A_PtrSize ? "UPtr" : "UInt", pGraphics, "float", x, "float", y, "int", MatrixOrder)
}

Gdip_ResetWorldTransform(pGraphics)
{
    return DllCall("gdiplus\GdipResetWorldTransform", A_PtrSize ? "UPtr" : "UInt", pGraphics)
}

Gdip_GetRotatedTranslation(Width, Height, Angle, ByRef xTranslation, ByRef yTranslation)
{
    pi := 3.14159, TAngle := Angle*(pi/180)

    Bound := (Angle >= 0) ? Mod(Angle, 360) : 360-Mod(-Angle, -360)
    if ((Bound >= 0) && (Bound <= 90))
        xTranslation := Height*Sin(TAngle), yTranslation := 0
    else if ((Bound > 90) && (Bound <= 180))
        xTranslation := (Height*Sin(TAngle))-(Width*Cos(TAngle)), yTranslation := -Height*Cos(TAngle)
    else if ((Bound > 180) && (Bound <= 270))
        xTranslation := -(Width*Cos(TAngle)), yTranslation := -(Height*Cos(TAngle))-(Width*Sin(TAngle))
    else if ((Bound > 270) && (Bound <= 360))
        xTranslation := 0, yTranslation := -Width*Sin(TAngle)
}

Gdip_GetRotatedDimensions(Width, Height, Angle, ByRef RWidth, ByRef RHeight)
{
    pi := 3.14159, TAngle := Angle*(pi/180)
    if !(Width && Height)
        return -1
    RWidth := Ceil(Abs(Width*Cos(TAngle))+Abs(Height*Sin(TAngle)))
    RHeight := Ceil(Abs(Width*Sin(TAngle))+Abs(Height*Cos(Tangle)))
}

Gdip_ImageRotateFlip(pBitmap, RotateFlipType=1)
{
    return DllCall("gdiplus\GdipImageRotateFlip", A_PtrSize ? "UPtr" : "UInt", pBitmap, "int", RotateFlipType)
}

; Replace = 0
; Intersect = 1
; Union = 2
; Xor = 3
; Exclude = 4
; Complement = 5
Gdip_SetClipRect(pGraphics, x, y, w, h, CombineMode=0)
{
   return DllCall("gdiplus\GdipSetClipRect",  A_PtrSize ? "UPtr" : "UInt", pGraphics, "float", x, "float", y, "float", w, "float", h, "int", CombineMode)
}

Gdip_SetClipPath(pGraphics, Path, CombineMode=0)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"
    return DllCall("gdiplus\GdipSetClipPath", Ptr, pGraphics, Ptr, Path, "int", CombineMode)
}

Gdip_ResetClip(pGraphics)
{
   return DllCall("gdiplus\GdipResetClip", A_PtrSize ? "UPtr" : "UInt", pGraphics)
}

Gdip_GetClipRegion(pGraphics)
{
    Region := Gdip_CreateRegion()
    DllCall("gdiplus\GdipGetClip", A_PtrSize ? "UPtr" : "UInt", pGraphics, "UInt*", Region)
    return Region
}

Gdip_SetClipRegion(pGraphics, Region, CombineMode=0)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("gdiplus\GdipSetClipRegion", Ptr, pGraphics, Ptr, Region, "int", CombineMode)
}

Gdip_CreateRegion()
{
    DllCall("gdiplus\GdipCreateRegion", "UInt*", Region)
    return Region
}

Gdip_DeleteRegion(Region)
{
    return DllCall("gdiplus\GdipDeleteRegion", A_PtrSize ? "UPtr" : "UInt", Region)
}

;#####################################################################################
; BitmapLockBits
;#####################################################################################

Gdip_LockBits(pBitmap, x, y, w, h, ByRef Stride, ByRef Scan0, ByRef BitmapData, LockMode = 3, PixelFormat = 0x26200a)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    CreateRect(Rect, x, y, w, h)
    VarSetCapacity(BitmapData, 16+2*(A_PtrSize ? A_PtrSize : 4), 0)
    E := DllCall("Gdiplus\GdipBitmapLockBits", Ptr, pBitmap, Ptr, &Rect, "uint", LockMode, "int", PixelFormat, Ptr, &BitmapData)
    Stride := NumGet(BitmapData, 8, "Int")
    Scan0 := NumGet(BitmapData, 16, Ptr)
    return E
}

;#####################################################################################

Gdip_UnlockBits(pBitmap, ByRef BitmapData)
{
    Ptr := A_PtrSize ? "UPtr" : "UInt"

    return DllCall("Gdiplus\GdipBitmapUnlockBits", Ptr, pBitmap, Ptr, &BitmapData)
}

;#####################################################################################

Gdip_SetLockBitPixel(ARGB, Scan0, x, y, Stride)
{
    Numput(ARGB, Scan0+0, (x*4)+(y*Stride), "UInt")
}

;#####################################################################################

Gdip_GetLockBitPixel(Scan0, x, y, Stride)
{
    return NumGet(Scan0+0, (x*4)+(y*Stride), "UInt")
}

;#####################################################################################

Gdip_PixelateBitmap(pBitmap, ByRef pBitmapOut, BlockSize)
{
    static PixelateBitmap

    Ptr := A_PtrSize ? "UPtr" : "UInt"

    if (!PixelateBitmap)
    {
        if A_PtrSize != 8 ; x86 machine code
        MCode_PixelateBitmap =
        (LTrim Join
        558BEC83EC3C8B4514538B5D1C99F7FB56578BC88955EC894DD885C90F8E830200008B451099F7FB8365DC008365E000894DC88955F08945E833FF897DD4
        397DE80F8E160100008BCB0FAFCB894DCC33C08945F88945FC89451C8945143BD87E608B45088D50028BC82BCA8BF02BF2418945F48B45E02955F4894DC4
        8D0CB80FAFCB03CA895DD08BD1895DE40FB64416030145140FB60201451C8B45C40FB604100145FC8B45F40FB604020145F883C204FF4DE475D6034D18FF
        4DD075C98B4DCC8B451499F7F98945148B451C99F7F989451C8B45FC99F7F98945FC8B45F899F7F98945F885DB7E648B450C8D50028BC82BCA83C103894D
        C48BC82BCA41894DF48B4DD48945E48B45E02955E48D0C880FAFCB03CA895DD08BD18BF38A45148B7DC48804178A451C8B7DF488028A45FC8804178A45F8
        8B7DE488043A83C2044E75DA034D18FF4DD075CE8B4DCC8B7DD447897DD43B7DE80F8CF2FEFFFF837DF0000F842C01000033C08945F88945FC89451C8945
        148945E43BD87E65837DF0007E578B4DDC034DE48B75E80FAF4D180FAFF38B45088D500203CA8D0CB18BF08BF88945F48B45F02BF22BFA2955F48945CC0F
        B6440E030145140FB60101451C0FB6440F010145FC8B45F40FB604010145F883C104FF4DCC75D8FF45E4395DE47C9B8B4DF00FAFCB85C9740B8B451499F7
        F9894514EB048365140033F63BCE740B8B451C99F7F989451CEB0389751C3BCE740B8B45FC99F7F98945FCEB038975FC3BCE740B8B45F899F7F98945F8EB
        038975F88975E43BDE7E5A837DF0007E4C8B4DDC034DE48B75E80FAF4D180FAFF38B450C8D500203CA8D0CB18BF08BF82BF22BFA2BC28B55F08955CC8A55
        1488540E038A551C88118A55FC88540F018A55F888140183C104FF4DCC75DFFF45E4395DE47CA68B45180145E0015DDCFF4DC80F8594FDFFFF8B451099F7
        FB8955F08945E885C00F8E450100008B45EC0FAFC38365DC008945D48B45E88945CC33C08945F88945FC89451C8945148945103945EC7E6085DB7E518B4D
        D88B45080FAFCB034D108D50020FAF4D18034DDC8BF08BF88945F403CA2BF22BFA2955F4895DC80FB6440E030145140FB60101451C0FB6440F010145FC8B
        45F40FB604080145F883C104FF4DC875D8FF45108B45103B45EC7CA08B4DD485C9740B8B451499F7F9894514EB048365140033F63BCE740B8B451C99F7F9
        89451CEB0389751C3BCE740B8B45FC99F7F98945FCEB038975FC3BCE740B8B45F899F7F98945F8EB038975F88975103975EC7E5585DB7E468B4DD88B450C
        0FAFCB034D108D50020FAF4D18034DDC8BF08BF803CA2BF22BFA2BC2895DC88A551488540E038A551C88118A55FC88540F018A55F888140183C104FF4DC8
        75DFFF45108B45103B45EC7CAB8BC3C1E0020145DCFF4DCC0F85CEFEFFFF8B4DEC33C08945F88945FC89451C8945148945103BC87E6C3945F07E5C8B4DD8
        8B75E80FAFCB034D100FAFF30FAF4D188B45088D500203CA8D0CB18BF08BF88945F48B45F02BF22BFA2955F48945C80FB6440E030145140FB60101451C0F
        B6440F010145FC8B45F40FB604010145F883C104FF4DC875D833C0FF45108B4DEC394D107C940FAF4DF03BC874068B451499F7F933F68945143BCE740B8B
        451C99F7F989451CEB0389751C3BCE740B8B45FC99F7F98945FCEB038975FC3BCE740B8B45F899F7F98945F8EB038975F88975083975EC7E63EB0233F639
        75F07E4F8B4DD88B75E80FAFCB034D080FAFF30FAF4D188B450C8D500203CA8D0CB18BF08BF82BF22BFA2BC28B55F08955108A551488540E038A551C8811
        8A55FC88540F018A55F888140883C104FF4D1075DFFF45088B45083B45EC7C9F5F5E33C05BC9C21800
        )
        else ; x64 machine code
        MCode_PixelateBitmap =
        (LTrim Join
        4489442418488954241048894C24085355565741544155415641574883EC28418BC1448B8C24980000004C8BDA99488BD941F7F9448BD0448BFA8954240C
        448994248800000085C00F8E9D020000418BC04533E4458BF299448924244C8954241041F7F933C9898C24980000008BEA89542404448BE889442408EB05
        4C8B5C24784585ED0F8E1A010000458BF1418BFD48897C2418450FAFF14533D233F633ED4533E44533ED4585C97E5B4C63BC2490000000418D040A410FAF
        C148984C8D441802498BD9498BD04D8BD90FB642010FB64AFF4403E80FB60203E90FB64AFE4883C2044403E003F149FFCB75DE4D03C748FFCB75D0488B7C
        24188B8C24980000004C8B5C2478418BC59941F7FE448BE8418BC49941F7FE448BE08BC59941F7FE8BE88BC69941F7FE8BF04585C97E4048639C24900000
        004103CA4D8BC1410FAFC94863C94A8D541902488BCA498BC144886901448821408869FF408871FE4883C10448FFC875E84803D349FFC875DA8B8C249800
        0000488B5C24704C8B5C24784183C20448FFCF48897C24180F850AFFFFFF8B6C2404448B2424448B6C24084C8B74241085ED0F840A01000033FF33DB4533
        DB4533D24533C04585C97E53488B74247085ED7E42438D0C04418BC50FAF8C2490000000410FAFC18D04814863C8488D5431028BCD0FB642014403D00FB6
        024883C2044403D80FB642FB03D80FB642FA03F848FFC975DE41FFC0453BC17CB28BCD410FAFC985C9740A418BC299F7F98BF0EB0233F685C9740B418BC3
        99F7F9448BD8EB034533DB85C9740A8BC399F7F9448BD0EB034533D285C9740A8BC799F7F9448BC0EB034533C033D24585C97E4D4C8B74247885ED7E3841
        8D0C14418BC50FAF8C2490000000410FAFC18D04814863C84A8D4431028BCD40887001448818448850FF448840FE4883C00448FFC975E8FFC2413BD17CBD
        4C8B7424108B8C2498000000038C2490000000488B5C24704503E149FFCE44892424898C24980000004C897424100F859EFDFFFF448B7C240C448B842480
        000000418BC09941F7F98BE8448BEA89942498000000896C240C85C00F8E3B010000448BAC2488000000418BCF448BF5410FAFC9898C248000000033FF33
        ED33F64533DB4533D24533C04585FF7E524585C97E40418BC5410FAFC14103C00FAF84249000000003C74898488D541802498BD90FB642014403D00FB602
        4883C2044403D80FB642FB03F00FB642FA03E848FFCB75DE488B5C247041FFC0453BC77CAE85C9740B418BC299F7F9448BE0EB034533E485C9740A418BC3
        99F7F98BD8EB0233DB85C9740A8BC699F7F9448BD8EB034533DB85C9740A8BC599F7F9448BD0EB034533D24533C04585FF7E4E488B4C24784585C97E3541
        8BC5410FAFC14103C00FAF84249000000003C74898488D540802498BC144886201881A44885AFF448852FE4883C20448FFC875E941FFC0453BC77CBE8B8C
        2480000000488B5C2470418BC1C1E00203F849FFCE0F85ECFEFFFF448BAC24980000008B6C240C448BA4248800000033FF33DB4533DB4533D24533C04585
        FF7E5A488B7424704585ED7E48418BCC8BC5410FAFC94103C80FAF8C2490000000410FAFC18D04814863C8488D543102418BCD0FB642014403D00FB60248
        83C2044403D80FB642FB03D80FB642FA03F848FFC975DE41FFC0453BC77CAB418BCF410FAFCD85C9740A418BC299F7F98BF0EB0233F685C9740B418BC399
        F7F9448BD8EB034533DB85C9740A8BC399F7F9448BD0EB034533D285C9740A8BC799F7F9448BC0EB034533C033D24585FF7E4E4585ED7E42418BCC8BC541
        0FAFC903CA0FAF8C2490000000410FAFC18D04814863C8488B442478488D440102418BCD40887001448818448850FF448840FE4883C00448FFC975E8FFC2
        413BD77CB233C04883C428415F415E415D415C5F5E5D5BC3
        )

        VarSetCapacity(PixelateBitmap, StrLen(MCode_PixelateBitmap)//2)
        Loop % StrLen(MCode_PixelateBitmap)//2      ;%
            NumPut("0x" SubStr(MCode_PixelateBitmap, (2*A_Index)-1, 2), PixelateBitmap, A_Index-1, "UChar")
        DllCall("VirtualProtect", Ptr, &PixelateBitmap, Ptr, VarSetCapacity(PixelateBitmap), "uint", 0x40, A_PtrSize ? "UPtr*" : "UInt*", 0)
    }

    Gdip_GetImageDimensions(pBitmap, Width, Height)

    if (Width != Gdip_GetImageWidth(pBitmapOut) || Height != Gdip_GetImageHeight(pBitmapOut))
        return -1
    if (BlockSize > Width || BlockSize > Height)
        return -2

    E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
    E2 := Gdip_LockBits(pBitmapOut, 0, 0, Width, Height, Stride2, Scan02, BitmapData2)
    if (E1 || E2)
        return -3

    E := DllCall(&PixelateBitmap, Ptr, Scan01, Ptr, Scan02, "int", Width, "int", Height, "int", Stride1, "int", BlockSize)

    Gdip_UnlockBits(pBitmap, BitmapData1), Gdip_UnlockBits(pBitmapOut, BitmapData2)
    return 0
}

;#####################################################################################

Gdip_ToARGB(A, R, G, B)
{
    return (A << 24) | (R << 16) | (G << 8) | B
}

;#####################################################################################

Gdip_FromARGB(ARGB, ByRef A, ByRef R, ByRef G, ByRef B)
{
    A := (0xff000000 & ARGB) >> 24
    R := (0x00ff0000 & ARGB) >> 16
    G := (0x0000ff00 & ARGB) >> 8
    B := 0x000000ff & ARGB
}

;#####################################################################################

Gdip_AFromARGB(ARGB)
{
    return (0xff000000 & ARGB) >> 24
}

;#####################################################################################

Gdip_RFromARGB(ARGB)
{
    return (0x00ff0000 & ARGB) >> 16
}

;#####################################################################################

Gdip_GFromARGB(ARGB)
{
    return (0x0000ff00 & ARGB) >> 8
}

;#####################################################################################

Gdip_BFromARGB(ARGB)
{
    return 0x000000ff & ARGB
}

;#####################################################################################

StrGetB(Address, Length=-1, Encoding=0)
{
    ; Flexible parameter handling:
    if Length is not integer
    Encoding := Length,  Length := -1

    ; Check for obvious errors.
    if (Address+0 < 1024)
        return

    ; Ensure 'Encoding' contains a numeric identifier.
    if Encoding = UTF-16
        Encoding = 1200
    else if Encoding = UTF-8
        Encoding = 65001
    else if SubStr(Encoding,1,2)="CP"
        Encoding := SubStr(Encoding,3)

    if !Encoding ; "" or 0
    {
        ; No conversion necessary, but we might not want the whole string.
        if (Length == -1)
            Length := DllCall("lstrlen", "uint", Address)
        VarSetCapacity(String, Length)
        DllCall("lstrcpyn", "str", String, "uint", Address, "int", Length + 1)
    }
    else if Encoding = 1200 ; UTF-16
    {
        char_count := DllCall("WideCharToMultiByte", "uint", 0, "uint", 0x400, "uint", Address, "int", Length, "uint", 0, "uint", 0, "uint", 0, "uint", 0)
        VarSetCapacity(String, char_count)
        DllCall("WideCharToMultiByte", "uint", 0, "uint", 0x400, "uint", Address, "int", Length, "str", String, "int", char_count, "uint", 0, "uint", 0)
    }
    else if Encoding is integer
    {
        ; Convert from target encoding to UTF-16 then to the active code page.
        char_count := DllCall("MultiByteToWideChar", "uint", Encoding, "uint", 0, "uint", Address, "int", Length, "uint", 0, "int", 0)
        VarSetCapacity(String, char_count * 2)
        char_count := DllCall("MultiByteToWideChar", "uint", Encoding, "uint", 0, "uint", Address, "int", Length, "uint", &String, "int", char_count * 2)
        String := StrGetB(&String, char_count, 1200)
    }

    return String
}
